"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renameSetupMfeGeneratorUsages = exports.replaceExportedMFETypes = exports.replaceNrwlAngularMfImport = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const NRWL_ANGULAR_MFE_STATIC_IMPORT_SELECTOR = 'ImportDeclaration > StringLiteral[value="@nrwl/angular/mfe"]';
const NRWL_ANGULAR_MFE_DYNAMIC_IMPORT_SELECTOR = 'CallExpression:has(ImportKeyword) > StringLiteral[value="@nrwl/angular/mfe"]';
const NRWL_ANGULAR_MFE_TYPES_SELECTOR = 'ImportDeclaration:has(StringLiteral[value=@nrwl/angular/module-federation]) > ImportClause > NamedImports';
function replaceNrwlAngularMfImport(fileContents) {
    let fileAst = tsquery_1.tsquery.ast(fileContents);
    if (fileContents.includes('@nrwl/angular/mfe')) {
        // This file definitely contains the string, however, we're interested in whether it is an import
        const staticQueryResult = (0, tsquery_1.tsquery)(fileAst, NRWL_ANGULAR_MFE_STATIC_IMPORT_SELECTOR, {
            visitAllChildren: true,
        });
        if (staticQueryResult && staticQueryResult.length > 0) {
            fileContents = `${fileContents.slice(0, staticQueryResult[0].getStart())}'@nrwl/angular/mf'${fileContents.slice(staticQueryResult[0].getEnd())}`;
        }
        fileAst = tsquery_1.tsquery.ast(fileContents);
        const dynamicQueryResult = (0, tsquery_1.tsquery)(fileAst, NRWL_ANGULAR_MFE_DYNAMIC_IMPORT_SELECTOR, {
            visitAllChildren: true,
        });
        if (dynamicQueryResult && dynamicQueryResult.length > 0) {
            fileContents = `${fileContents.slice(0, dynamicQueryResult[0].getStart())}'@nrwl/angular/mf'${fileContents.slice(dynamicQueryResult[0].getEnd())}`;
        }
    }
    return fileContents;
}
exports.replaceNrwlAngularMfImport = replaceNrwlAngularMfImport;
function replaceExportedMFETypes(fileContents) {
    const ast = tsquery_1.tsquery.ast(fileContents);
    const queryResult = (0, tsquery_1.tsquery)(ast, NRWL_ANGULAR_MFE_TYPES_SELECTOR, {
        visitAllChildren: true,
    });
    if (queryResult && queryResult.length > 0) {
        const TYPES_IMPORTED_FROM_NRWL_REGEX = /(MFERemotes|MFEConfig)+.*from+.+(@nrwl\/angular\/module-federation)+/g;
        if (TYPES_IMPORTED_FROM_NRWL_REGEX.test(fileContents)) {
            fileContents = fileContents.replace(/MFERemotes/g, 'MFRemotes');
            fileContents = fileContents.replace(/MFEConfig/g, 'MFConfig');
        }
    }
    return fileContents;
}
exports.replaceExportedMFETypes = replaceExportedMFETypes;
function renameSetupMfeGeneratorUsages(fileContents) {
    // Attempt to update any custom generator usage of the changed generators
    const NRWL_SETUP_MFE_IMPORT_SELECTOR = 'ImportDeclaration:has(StringLiteral[value=@nrwl/angular/generators]) > ImportClause:has(NamedImports:has(ImportSpecifier > Identifier[name=setupMfe]))';
    const SETUP_MFE_IMPORTED_FROM_NRWL_REGEX = /(setupMfe)+.*from+.+(@nrwl\/angular\/generators)+/g;
    const SETUP_MFE_FUNCTION_CALL_MFE_TYPE_PROPERTY_ASSIGNMENT_SELECTOR = 'CallExpression:has(Identifier[name=setupMf]) ObjectLiteralExpression > PropertyAssignment > Identifier[name=mfeType]';
    let ast = tsquery_1.tsquery.ast(fileContents);
    let queryResult = (0, tsquery_1.tsquery)(ast, NRWL_SETUP_MFE_IMPORT_SELECTOR, {
        visitAllChildren: true,
    });
    if (queryResult &&
        queryResult.length > 0 &&
        SETUP_MFE_IMPORTED_FROM_NRWL_REGEX.test(fileContents)) {
        fileContents = fileContents.replace(/setupMfe/g, 'setupMf');
    }
    ast = tsquery_1.tsquery.ast(fileContents);
    queryResult = (0, tsquery_1.tsquery)(ast, SETUP_MFE_FUNCTION_CALL_MFE_TYPE_PROPERTY_ASSIGNMENT_SELECTOR, {
        visitAllChildren: true,
    });
    while (queryResult && queryResult.length > 0) {
        const node = queryResult[0];
        fileContents = `${fileContents.slice(0, node.getStart())}mfType${fileContents.slice(node.getEnd())}`;
        ast = tsquery_1.tsquery.ast(fileContents);
        queryResult = (0, tsquery_1.tsquery)(ast, SETUP_MFE_FUNCTION_CALL_MFE_TYPE_PROPERTY_ASSIGNMENT_SELECTOR, {
            visitAllChildren: true,
        });
    }
    return fileContents;
}
exports.renameSetupMfeGeneratorUsages = renameSetupMfeGeneratorUsages;
function default_1(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        (0, devkit_1.visitNotIgnoredFiles)(tree, '/', (path) => {
            const pathExtName = (0, path_1.extname)(path);
            if (pathExtName !== '.ts' && pathExtName !== '.js') {
                return;
            }
            let fileContents = tree.read(path, 'utf-8');
            fileContents = replaceNrwlAngularMfImport(fileContents);
            if (pathExtName === '.ts') {
                // Only TS files can import types and interfaces
                fileContents = replaceExportedMFETypes(fileContents);
                fileContents = renameSetupMfeGeneratorUsages(fileContents);
            }
            tree.write(path, fileContents);
        });
    });
}
exports.default = default_1;
