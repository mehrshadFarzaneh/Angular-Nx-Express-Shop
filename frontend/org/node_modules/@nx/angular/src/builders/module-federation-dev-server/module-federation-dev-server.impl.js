"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeModuleFederationDevServerBuilder = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const ngcli_adapter_1 = require("nx/src/adapter/ngcli-adapter");
const webpack_dev_server_impl_1 = require("../webpack-dev-server/webpack-dev-server.impl");
const project_graph_1 = require("nx/src/project-graph/project-graph");
const module_federation_1 = require("../utilities/module-federation");
const fs_1 = require("fs");
const path_1 = require("path");
const find_matching_projects_1 = require("nx/src/utils/find-matching-projects");
function executeModuleFederationDevServerBuilder(schema, context) {
    var _a, _b, _c;
    const options = tslib_1.__rest(schema, []);
    const projectGraph = (0, devkit_1.readCachedProjectGraph)();
    const { projects: workspaceProjects } = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(projectGraph);
    const ws = new devkit_1.Workspaces(devkit_1.workspaceRoot);
    const project = workspaceProjects[context.target.project];
    let pathToManifestFile = (0, path_1.join)(context.workspaceRoot, project.sourceRoot, 'assets/module-federation.manifest.json');
    if (options.pathToManifestFile) {
        const userPathToManifestFile = (0, path_1.join)(context.workspaceRoot, options.pathToManifestFile);
        if (!(0, fs_1.existsSync)(userPathToManifestFile)) {
            throw new Error(`The provided Module Federation manifest file path does not exist. Please check the file exists at "${userPathToManifestFile}".`);
        }
        else if ((0, path_1.extname)(options.pathToManifestFile) !== '.json') {
            throw new Error(`The Module Federation manifest file must be a JSON. Please ensure the file at ${userPathToManifestFile} is a JSON.`);
        }
        pathToManifestFile = userPathToManifestFile;
    }
    (0, module_federation_1.validateDevRemotes)(options, workspaceProjects);
    const remotesToSkip = new Set((_a = (0, find_matching_projects_1.findMatchingProjects)(options.skipRemotes, projectGraph.nodes)) !== null && _a !== void 0 ? _a : []);
    const staticRemotes = (0, module_federation_1.getStaticRemotes)(project, context, workspaceProjects, remotesToSkip);
    const dynamicRemotes = (0, module_federation_1.getDynamicRemotes)(project, context, workspaceProjects, remotesToSkip, pathToManifestFile);
    const remotes = [...staticRemotes, ...dynamicRemotes];
    const devServeRemotes = !options.devRemotes
        ? []
        : Array.isArray(options.devRemotes)
            ? (0, find_matching_projects_1.findMatchingProjects)(options.devRemotes, projectGraph.nodes)
            : (0, find_matching_projects_1.findMatchingProjects)([options.devRemotes], projectGraph.nodes);
    for (const remote of remotes) {
        const isDev = devServeRemotes.includes(remote);
        const target = isDev ? 'serve' : 'serve-static';
        if (!((_b = workspaceProjects[remote].targets) === null || _b === void 0 ? void 0 : _b[target])) {
            throw new Error(`Could not find "${target}" target in "${remote}" project.`);
        }
        else if (!((_c = workspaceProjects[remote].targets) === null || _c === void 0 ? void 0 : _c[target].executor)) {
            throw new Error(`Could not find executor for "${target}" target in "${remote}" project.`);
        }
        const runOptions = {};
        if (options.verbose) {
            const [collection, executor] = workspaceProjects[remote].targets[target].executor.split(':');
            const { schema } = ws.readExecutor(collection, executor);
            if (schema.additionalProperties || 'verbose' in schema.properties) {
                runOptions.verbose = options.verbose;
            }
        }
        (0, ngcli_adapter_1.scheduleTarget)(context.workspaceRoot, {
            project: remote,
            target,
            configuration: context.target.configuration,
            runOptions,
        }, options.verbose).then((obs) => {
            obs.toPromise().catch((err) => {
                throw new Error(`Remote '${remote}' failed to serve correctly due to the following: \r\n${err.toString()}`);
            });
        });
    }
    return (0, webpack_dev_server_impl_1.executeWebpackDevServerBuilder)(options, context);
}
exports.executeModuleFederationDevServerBuilder = executeModuleFederationDevServerBuilder;
exports.default = require('@angular-devkit/architect').createBuilder(executeModuleFederationDevServerBuilder);
