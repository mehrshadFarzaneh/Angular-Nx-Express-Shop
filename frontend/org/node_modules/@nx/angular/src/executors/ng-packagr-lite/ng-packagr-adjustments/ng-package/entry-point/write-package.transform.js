"use strict";
/**
 * Adapted from the original ng-packagr.
 *
 * Changes made:
 * - Change the package.json metadata to only use the ESM2022 output.
 * - Change the package.json metadata to only use the ESM2020 output (Angular < 16).
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.nxWritePackageTransform = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const node_1 = require("ng-packagr/lib/graph/node");
const transform_1 = require("ng-packagr/lib/graph/transform");
const nodes_1 = require("ng-packagr/lib/ng-package/nodes");
const fs_1 = require("ng-packagr/lib/utils/fs");
const glob_1 = require("ng-packagr/lib/utils/glob");
const path_1 = require("ng-packagr/lib/utils/path");
const path = require("path");
const angular_version_utils_1 = require("../../../../utilities/angular-version-utils");
const nxWritePackageTransform = (options) => (0, transform_1.transformFromPromise)((graph) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const entryPoint = graph.find((0, nodes_1.isEntryPointInProgress)());
    const ngEntryPoint = entryPoint.data.entryPoint;
    const ngPackageNode = graph.find(nodes_1.isPackage);
    const ngPackage = ngPackageNode.data;
    const { destinationFiles } = entryPoint.data;
    const angularVersion = (0, angular_version_utils_1.getInstalledAngularVersionInfo)();
    if (!ngEntryPoint.isSecondaryEntryPoint) {
        devkit_1.logger.log('Copying assets');
        try {
            yield copyAssets(graph, entryPoint, ngPackageNode, angularVersion);
        }
        catch (error) {
            throw error;
        }
    }
    // 6. WRITE PACKAGE.JSON
    // As of APF 14 only the primary entrypoint has a package.json
    if (!ngEntryPoint.isSecondaryEntryPoint) {
        try {
            devkit_1.logger.info('Writing package manifest');
            const relativeUnixFromDestPath = (filePath) => (0, path_1.ensureUnixPath)(path.relative(ngEntryPoint.destinationPath, filePath));
            yield writePackageJson(ngEntryPoint, ngPackage, Object.assign(Object.assign({}, (angularVersion.major < 16
                ? {
                    module: relativeUnixFromDestPath(destinationFiles.esm2020),
                    es2020: relativeUnixFromDestPath(destinationFiles.esm2020),
                    esm2020: relativeUnixFromDestPath(destinationFiles.esm2020),
                }
                : {
                    module: relativeUnixFromDestPath(destinationFiles.esm2022),
                })), { typings: relativeUnixFromDestPath(destinationFiles.declarations), exports: generatePackageExports(ngEntryPoint, graph, angularVersion), 
                // webpack v4+ specific flag to enable advanced optimizations and code splitting
                sideEffects: (_a = ngEntryPoint.packageJson.sideEffects) !== null && _a !== void 0 ? _a : false }), !!options.watch);
        }
        catch (error) {
            throw error;
        }
    }
    else if (options.watch) {
        // update the watch version of the primary entry point `package.json` file.
        // this is needed because of Webpack's 5 `cachemanagedpaths`
        // https://github.com/ng-packagr/ng-packagr/issues/2069
        const primary = ngPackageNode.data.primary;
        const packageJsonPath = path.join(primary.destinationPath, 'package.json');
        if (yield (0, fs_1.exists)(packageJsonPath)) {
            const packageJson = JSON.parse(yield (0, fs_1.readFile)(packageJsonPath, { encoding: 'utf8' }));
            packageJson.version = generateWatchVersion();
            yield (0, fs_1.writeFile)(path.join(primary.destinationPath, 'package.json'), JSON.stringify(packageJson, undefined, 2));
        }
    }
    devkit_1.logger.info(`Built ${ngEntryPoint.moduleId}`);
    return graph;
}));
exports.nxWritePackageTransform = nxWritePackageTransform;
function copyAssets(graph, entryPointNode, ngPackageNode, angularVersion) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const ngPackage = ngPackageNode.data;
        const globsForceIgnored = [
            '.gitkeep',
            '**/.DS_Store',
            '**/Thumbs.db',
            `${ngPackage.dest}/**`,
        ];
        const assets = [];
        for (const assetPath of ngPackage.assets) {
            let asset;
            if (typeof assetPath === 'object') {
                asset = Object.assign({}, assetPath);
            }
            else {
                const [isDir, isFile] = yield (0, fs_1.stat)(path.join(ngPackage.src, assetPath))
                    .then((stats) => [stats.isDirectory(), stats.isFile()])
                    .catch(() => [false, false]);
                if (isDir) {
                    asset = { glob: '**/*', input: assetPath, output: assetPath };
                }
                else if (isFile) {
                    // filenames are their own glob
                    asset = {
                        glob: path.basename(assetPath),
                        input: path.dirname(assetPath),
                        output: path.dirname(assetPath),
                    };
                }
                else {
                    asset = { glob: assetPath, input: '/', output: '/' };
                }
            }
            asset.input = path.join(ngPackage.src, asset.input);
            asset.output = path.join(ngPackage.dest, asset.output);
            const isAncestorPath = (target, datum) => path.relative(datum, target).startsWith('..');
            if (isAncestorPath(asset.input, ngPackage.src)) {
                throw new Error('Cannot read assets from a location outside of the project root.');
            }
            if (isAncestorPath(asset.output, ngPackage.dest)) {
                throw new Error('Cannot write assets to a location outside of the output path.');
            }
            assets.push(asset);
        }
        for (const asset of assets) {
            const globOptions = {
                cwd: asset.input,
                ignore: [...((_a = asset.ignore) !== null && _a !== void 0 ? _a : []), ...globsForceIgnored],
                dot: true,
            };
            if (angularVersion.major < 16) {
                // versions lower than v16 support these properties
                globOptions.cache = ngPackageNode.cache.globCache;
                globOptions.nodir = true;
                globOptions.follow = asset.followSymlinks;
            }
            else {
                // starting in v16 these properties are supported
                globOptions.onlyFiles = true;
                globOptions.followSymbolicLinks = asset.followSymlinks;
            }
            const filePaths = yield (0, glob_1.globFiles)(asset.glob, globOptions);
            for (const filePath of filePaths) {
                const fileSrcFullPath = path.join(asset.input, filePath);
                const fileDestFullPath = path.join(asset.output, filePath);
                const nodeUri = (0, nodes_1.fileUrl)((0, path_1.ensureUnixPath)(fileSrcFullPath));
                let node = graph.get(nodeUri);
                if (!node) {
                    node = new node_1.Node(nodeUri);
                    graph.put(node);
                }
                entryPointNode.dependsOn(node);
                yield (0, fs_1.copyFile)(fileSrcFullPath, fileDestFullPath);
            }
        }
    });
}
/**
 * Creates and writes a `package.json` file of the entry point used by the `node_module`
 * resolution strategies.
 *
 * #### Example
 *
 * A consumer of the entry point depends on it by `import {..} from '@my/module/id';`.
 * The module id `@my/module/id` will be resolved to the `package.json` file that is written by
 * this build step.
 * The properties `main`, `module`, `typings` (and so on) in the `package.json` point to the
 * flattened JavaScript bundles, type definitions, (...).
 *
 * @param entryPoint An entry point of an Angular package / library
 * @param additionalProperties Additional properties, e.g. binary artefacts (bundle files), to merge into `package.json`
 */
function writePackageJson(entryPoint, pkg, additionalProperties, isWatchMode) {
    var _a, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // set additional properties
        const packageJson = Object.assign(Object.assign({}, entryPoint.packageJson), additionalProperties);
        // read tslib version from `@angular/compiler` so that our tslib
        // version at least matches that of angular if we use require('tslib').version
        // it will get what installed and not the minimum version nor if it is a `~` or `^`
        // this is only required for primary
        if (isWatchMode) {
            // Needed because of Webpack's 5 `cachemanagedpaths`
            // https://github.com/angular/angular-cli/issues/20962
            packageJson.version = generateWatchVersion();
        }
        if (!((_a = packageJson.peerDependencies) === null || _a === void 0 ? void 0 : _a.tslib) &&
            !((_b = packageJson.dependencies) === null || _b === void 0 ? void 0 : _b.tslib)) {
            const { peerDependencies: angularPeerDependencies = {}, dependencies: angularDependencies = {}, } = require('@angular/compiler/package.json');
            const tsLibVersion = angularPeerDependencies.tslib || angularDependencies.tslib;
            if (tsLibVersion) {
                packageJson.dependencies = Object.assign(Object.assign({}, packageJson.dependencies), { tslib: tsLibVersion });
            }
        }
        else if ((_c = packageJson.peerDependencies) === null || _c === void 0 ? void 0 : _c.tslib) {
            devkit_1.logger.warn(`'tslib' is no longer recommended to be used as a 'peerDependencies'. Moving it to 'dependencies'.`);
            packageJson.dependencies = Object.assign(Object.assign({}, (packageJson.dependencies || {})), { tslib: packageJson.peerDependencies.tslib });
            delete packageJson.peerDependencies.tslib;
        }
        // Verify non-peerDependencies as they can easily lead to duplicate installs or version conflicts
        // in the node_modules folder of an application
        const allowedList = pkg.allowedNonPeerDependencies.map((value) => new RegExp(value));
        try {
            checkNonPeerDependencies(packageJson, 'dependencies', allowedList);
        }
        catch (e) {
            yield (0, fs_1.rmdir)(entryPoint.destinationPath, { recursive: true });
            throw e;
        }
        // Removes scripts from package.json after build
        if (packageJson.scripts) {
            if (pkg.keepLifecycleScripts !== true) {
                devkit_1.logger.info(`Removing scripts section in package.json as it's considered a potential security vulnerability.`);
                delete packageJson.scripts;
            }
            else {
                devkit_1.logger.warn(`You enabled keepLifecycleScripts explicitly. The scripts section in package.json will be published to npm.`);
            }
        }
        // keep the dist package.json clean
        // this will not throw if ngPackage field does not exist
        delete packageJson.ngPackage;
        const packageJsonPropertiesToDelete = [
            'stylelint',
            'prettier',
            'browserslist',
            'devDependencies',
            'jest',
            'workspaces',
            'husky',
        ];
        for (const prop of packageJsonPropertiesToDelete) {
            if (prop in packageJson) {
                delete packageJson[prop];
                devkit_1.logger.info(`Removing ${prop} section in package.json.`);
            }
        }
        packageJson.name = entryPoint.moduleId;
        yield (0, fs_1.writeFile)(path.join(entryPoint.destinationPath, 'package.json'), JSON.stringify(packageJson, undefined, 2));
    });
}
function checkNonPeerDependencies(packageJson, property, allowed) {
    if (!packageJson[property]) {
        return;
    }
    for (const dep of Object.keys(packageJson[property])) {
        if (!allowed.some((regex) => regex.test(dep))) {
            devkit_1.logger.warn(`Distributing npm packages with '${property}' is not recommended. Please consider adding ${dep} to 'peerDependencies' or remove it from '${property}'.`);
            throw new Error(`Dependency ${dep} must be explicitly allowed using the "allowedNonPeerDependencies" option.`);
        }
    }
}
/**
 * Generates the `package.json` package exports following APF v13.
 * This is supposed to match with: https://github.com/angular/angular/blob/e0667efa6eada64d1fb8b143840689090fc82e52/packages/bazel/src/ng_package/packager.ts#L415.
 */
function generatePackageExports({ destinationPath, packageJson }, graph, angularVersion) {
    const exports = packageJson.exports
        ? JSON.parse(JSON.stringify(packageJson.exports))
        : {};
    const insertMappingOrError = (subpath, mapping) => {
        var _a;
        (_a = exports[subpath]) !== null && _a !== void 0 ? _a : (exports[subpath] = {});
        const subpathExport = exports[subpath];
        // Go through all conditions that should be inserted. If the condition is already
        // manually set of the subpath export, we throw an error. In general, we allow for
        // additional conditions to be set. These will always precede the generated ones.
        for (const conditionName of Object.keys(mapping)) {
            if (subpathExport[conditionName] !== undefined) {
                devkit_1.logger.warn(`Found a conflicting export condition for "${subpath}". The "${conditionName}" ` +
                    `condition would be overridden by ng-packagr. Please unset it.`);
            }
            // **Note**: The order of the conditions is preserved even though we are setting
            // the conditions once at a time (the latest assignment will be at the end).
            subpathExport[conditionName] = mapping[conditionName];
        }
    };
    const relativeUnixFromDestPath = (filePath) => './' + (0, path_1.ensureUnixPath)(path.relative(destinationPath, filePath));
    insertMappingOrError('./package.json', { default: './package.json' });
    const entryPoints = graph.filter(nodes_1.isEntryPoint);
    for (const entryPoint of entryPoints) {
        const { destinationFiles, isSecondaryEntryPoint } = entryPoint.data.entryPoint;
        const subpath = isSecondaryEntryPoint
            ? `./${destinationFiles.directory}`
            : '.';
        // backward compat for Angular < 16
        const mapping = angularVersion.major < 16
            ? {
                types: relativeUnixFromDestPath(destinationFiles.declarations),
                es2020: relativeUnixFromDestPath(destinationFiles.esm2020),
                esm2020: relativeUnixFromDestPath(destinationFiles.esm2020),
                default: relativeUnixFromDestPath(destinationFiles.esm2020),
            }
            : {
                esm2022: relativeUnixFromDestPath(destinationFiles.esm2022),
                esm: relativeUnixFromDestPath(destinationFiles.esm2022),
                default: relativeUnixFromDestPath(destinationFiles.esm2022),
            };
        insertMappingOrError(subpath, mapping);
    }
    return exports;
}
/**
 * Generates a new version for the package `package.json` when runing in watch mode.
 */
function generateWatchVersion() {
    return `0.0.0-watch+${Date.now()}`;
}
