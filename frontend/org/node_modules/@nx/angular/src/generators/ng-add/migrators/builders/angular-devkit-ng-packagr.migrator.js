"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AngularDevkitNgPackagrMigrator = void 0;
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const path_1 = require("path");
const dependencies_1 = require("../../../utils/dependencies");
const builder_migrator_1 = require("./builder.migrator");
class AngularDevkitNgPackagrMigrator extends builder_migrator_1.BuilderMigrator {
    constructor(tree, project, projectConfig, logger) {
        super(tree, '@angular-devkit/build-angular:ng-packagr', undefined, project, projectConfig, logger);
    }
    migrate() {
        if (this.skipMigration) {
            return;
        }
        if (!this.targets.size) {
            this.logger.warn(`There is no target in the project configuration using the ${this.builderName} builder. This might not be an issue. ` +
                `Skipping updating the build configuration.`);
            return;
        }
        for (const [name, target] of this.targets) {
            this.updateTargetConfiguration(name, target);
            this.updateNgPackageJson(name, target);
            this.updateTsConfigs(name, target);
            this.updateCacheableOperations([name]);
            (0, dependencies_1.addBuildableLibrariesPostCssDependencies)(this.tree);
        }
    }
    updateTargetConfiguration(targetName, target) {
        target.executor = '@nx/angular:package';
        if (!target.options &&
            (!target.configurations || !Object.keys(target.configurations).length)) {
            this.logger.warn(`The target "${targetName}" is not specifying any options or configurations. Skipping updating the target configuration.`);
            return;
        }
        ['project', 'tsConfig'].forEach((option) => {
            var _a, _b;
            if ((_a = target.options) === null || _a === void 0 ? void 0 : _a[option]) {
                target.options[option] = (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(target.options[option]));
            }
            for (const configuration of Object.values((_b = target.configurations) !== null && _b !== void 0 ? _b : {})) {
                configuration[option] =
                    configuration[option] &&
                        (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(configuration[option]));
            }
        });
        (0, devkit_1.updateProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig));
    }
    updateNgPackageJson(targetName, target) {
        var _a;
        if (!((_a = target.options) === null || _a === void 0 ? void 0 : _a.project)) {
            this.logger.warn(`The "${targetName}" target does not have the "project" option configured. Skipping updating the ng-packagr project file ("ng-package.json").`);
            return;
        }
        else if (!this.tree.exists(target.options.project)) {
            this.logger.warn(`The ng-packagr project file "${this.originalProjectConfig.targets[targetName].options.project}" specified in the "${targetName}" ` +
                `target could not be found. Skipping updating the ng-packagr project file.`);
            return;
        }
        (0, devkit_1.updateJson)(this.tree, target.options.project, (ngPackageJson) => {
            const offset = (0, devkit_1.offsetFromRoot)(this.project.newRoot);
            ngPackageJson.$schema =
                ngPackageJson.$schema &&
                    `${offset}node_modules/ng-packagr/ng-package.schema.json`;
            ngPackageJson.dest = `${offset}dist/${this.project.name}`;
            return ngPackageJson;
        });
    }
    updateTsConfigs(targetName, target) {
        var _a, _b, _c, _d, _e, _f, _g;
        const tsConfigPath = (_b = (_a = target.options) === null || _a === void 0 ? void 0 : _a.tsConfig) !== null && _b !== void 0 ? _b : (_d = (_c = target.configurations) === null || _c === void 0 ? void 0 : _c.development) === null || _d === void 0 ? void 0 : _d.tsConfig;
        if (!tsConfigPath) {
            this.logger.warn(`The "${targetName}" target does not have the "tsConfig" option configured. Skipping updating the tsConfig file.`);
            return;
        }
        else if (!this.tree.exists(tsConfigPath)) {
            const originalTsConfigPath = ((_e = target.options) === null || _e === void 0 ? void 0 : _e.tsConfig)
                ? this.originalProjectConfig.targets[targetName].options.tsConfig
                : (_g = (_f = this.originalProjectConfig.targets[targetName].configurations) === null || _f === void 0 ? void 0 : _f.development) === null || _g === void 0 ? void 0 : _g.tsConfig;
            this.logger.warn(`The tsConfig file "${originalTsConfigPath}" specified in the "${targetName}" target could not be found. Skipping updating the tsConfig file.`);
            return;
        }
        const rootTsConfigFile = (0, js_1.getRootTsConfigPathInTree)(this.tree);
        const projectOffsetFromRoot = (0, devkit_1.offsetFromRoot)(this.projectConfig.root);
        this.updateTsConfigFile(tsConfigPath, rootTsConfigFile, projectOffsetFromRoot);
        (0, devkit_1.updateJson)(this.tree, tsConfigPath, (json) => {
            var _a, _b;
            if (!((_a = json.include) === null || _a === void 0 ? void 0 : _a.length) && !((_b = json.files) === null || _b === void 0 ? void 0 : _b.length)) {
                json.include = ['**/*.ts'];
            }
            return json;
        });
    }
}
exports.AngularDevkitNgPackagrMigrator = AngularDevkitNgPackagrMigrator;
