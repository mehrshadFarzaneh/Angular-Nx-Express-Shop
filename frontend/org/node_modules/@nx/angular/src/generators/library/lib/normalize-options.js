"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeOptions = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const get_import_path_1 = require("@nx/js/src/utils/get-import-path");
const get_npm_scope_1 = require("@nx/js/src/utils/package-json/get-npm-scope");
const linter_1 = require("@nx/linter");
const test_runners_1 = require("../../../utils/test-runners");
const project_1 = require("../../utils/project");
function normalizeOptions(host, schema) {
    var _a, _b, _c, _d;
    // Create a schema with populated default values
    const options = Object.assign({ buildable: false, linter: linter_1.Linter.EsLint, publishable: false, simpleName: false, skipFormat: false, unitTestRunner: test_runners_1.UnitTestRunner.Jest, 
        // Publishable libs cannot use `full` yet, so if its false then use the passed value or default to `full`
        compilationMode: schema.publishable
            ? 'partial'
            : (_a = schema.compilationMode) !== null && _a !== void 0 ? _a : 'full', skipModule: schema.skipModule || schema.standalone }, schema);
    const name = (0, devkit_1.names)(options.name).fileName;
    const { layoutDirectory, projectDirectory } = (0, devkit_1.extractLayoutDirectory)(options.directory);
    const fullProjectDirectory = projectDirectory
        ? `${(0, devkit_1.names)(projectDirectory).fileName}/${name}`.replace(/\/+/g, '/')
        : name;
    const { libsDir: defaultLibsDirectory, standaloneAsDefault } = (0, devkit_1.getWorkspaceLayout)(host);
    const npmScope = (0, get_npm_scope_1.getNpmScope)(host);
    const libsDir = layoutDirectory !== null && layoutDirectory !== void 0 ? layoutDirectory : defaultLibsDirectory;
    const projectName = fullProjectDirectory
        .replace(new RegExp('/', 'g'), '-')
        .replace(/-\d+/g, '');
    const fileName = options.simpleName ? name : projectName;
    const projectRoot = (0, devkit_1.joinPathFragments)(libsDir, fullProjectDirectory);
    const moduleName = `${(0, devkit_1.names)(fileName).className}Module`;
    const parsedTags = options.tags
        ? options.tags.split(',').map((s) => s.trim())
        : [];
    const modulePath = `${projectRoot}/src/lib/${fileName}.module.ts`;
    const prefix = (0, project_1.normalizeNewProjectPrefix)(options.prefix, npmScope, 'lib');
    options.standaloneConfig = (_b = options.standaloneConfig) !== null && _b !== void 0 ? _b : standaloneAsDefault;
    const importPath = options.importPath || (0, get_import_path_1.getImportPath)(host, fullProjectDirectory);
    const ngCliSchematicLibRoot = projectName;
    const allNormalizedOptions = Object.assign(Object.assign({}, options), { linter: (_c = options.linter) !== null && _c !== void 0 ? _c : linter_1.Linter.EsLint, unitTestRunner: (_d = options.unitTestRunner) !== null && _d !== void 0 ? _d : test_runners_1.UnitTestRunner.Jest, prefix, name: projectName, projectRoot, entryFile: 'index', moduleName, projectDirectory: fullProjectDirectory, modulePath,
        parsedTags,
        fileName,
        importPath,
        ngCliSchematicLibRoot, standaloneComponentName: `${(0, devkit_1.names)(name).className}Component` });
    const { displayBlock, inlineStyle, inlineTemplate, viewEncapsulation, changeDetection, style, skipTests, selector, skipSelector, flat } = allNormalizedOptions, libraryOptions = tslib_1.__rest(allNormalizedOptions, ["displayBlock", "inlineStyle", "inlineTemplate", "viewEncapsulation", "changeDetection", "style", "skipTests", "selector", "skipSelector", "flat"]);
    return {
        libraryOptions,
        componentOptions: {
            name: fileName,
            standalone: libraryOptions.standalone,
            displayBlock,
            inlineStyle,
            inlineTemplate,
            viewEncapsulation,
            changeDetection,
            style,
            skipTests,
            selector,
            skipSelector,
            flat,
        },
    };
}
exports.normalizeOptions = normalizeOptions;
