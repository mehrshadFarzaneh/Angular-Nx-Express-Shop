import { ROUTER_NAVIGATION } from '@ngrx/router-store';
import { isObservable, of } from 'rxjs';
import { catchError, concatMap, filter, groupBy, map, mergeMap, switchMap, } from 'rxjs/operators';
/**
 *
 * @whatItDoes Handles pessimistic updates (updating the server first).
 *
 * Updating the server, when implemented naively, suffers from race conditions and poor error handling.
 *
 * `pessimisticUpdate` addresses these problems. It runs all fetches in order, which removes race conditions
 * and forces the developer to handle errors.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('UPDATE_TODO'),
 *       pessimisticUpdate({
 *         // provides an action
 *         run: (action: UpdateTodo) => {
 *           // update the backend first, and then dispatch an action that will
 *           // update the client side
 *           return this.backend.updateTodo(action.todo.id, action.todo).pipe(
 *             map((updated) => ({
 *               type: 'UPDATE_TODO_SUCCESS',
 *               todo: updated,
 *             }))
 *           );
 *         },
 *         onError: (action: UpdateTodo, error: any) => {
 *           // we don't need to undo the changes on the client side.
 *           // we can dispatch an error, or simply log the error here and return `null`
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * Note that if you don't return a new action from the run callback, you must set the dispatch property
 * of the effect to false, like this:
 *
 * ```typescript
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       //...
 *     ), { dispatch: false }
 *   );
 * }
 * ```
 *
 * @param opts
 */
export function pessimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 *
 * @whatItDoes Handles optimistic updates (updating the client first).
 *
 * It runs all fetches in order, which removes race conditions and forces the developer to handle errors.
 *
 * When using `optimisticUpdate`, in case of a failure, the developer has already updated the state locally,
 * so the developer must provide an undo action.
 *
 * The error handling must be done in the callback, or by means of the undo action.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('UPDATE_TODO'),
 *       optimisticUpdate({
 *         // provides an action
 *         run: (action: UpdateTodo) => {
 *           return this.backend.updateTodo(action.todo.id, action.todo).pipe(
 *             mapTo({
 *               type: 'UPDATE_TODO_SUCCESS',
 *             })
 *           );
 *         },
 *         undoAction: (action: UpdateTodo, error: any) => {
 *           // dispatch an undo action to undo the changes in the client state
 *           return {
 *             type: 'UNDO_TODO_UPDATE',
 *             todo: action.todo,
 *           };
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * Note that if you don't return a new action from the run callback, you must set the dispatch property
 * of the effect to false, like this:
 *
 * ```typescript
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       //...
 *     ), { dispatch: false }
 *   );
 * }
 * ```
 *
 * @param opts
 */
export function optimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.undoAction)));
    };
}
/**
 *
 * @whatItDoes Handles data fetching.
 *
 * Data fetching implemented naively suffers from race conditions and poor error handling.
 *
 * `fetch` addresses these problems. It runs all fetches in order, which removes race conditions
 * and forces the developer to handle errors.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   loadTodos$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('GET_TODOS'),
 *       fetch({
 *         // provides an action
 *         run: (a: GetTodos) => {
 *           return this.backend.getAll().pipe(
 *             map((response) => ({
 *               type: 'TODOS',
 *               todos: response.todos,
 *             }))
 *           );
 *         },
 *         onError: (action: GetTodos, error: any) => {
 *           // dispatch an undo action to undo the changes in the client state
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * This is correct, but because it set the concurrency to 1, it may not be performant.
 *
 * To fix that, you can provide the `id` function, like this:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   loadTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('GET_TODO'),
 *       fetch({
 *         id: (todo: GetTodo) => {
 *           return todo.id;
 *         },
 *         // provides an action
 *         run: (todo: GetTodo) => {
 *           return this.backend.getTodo(todo.id).map((response) => ({
 *             type: 'LOAD_TODO_SUCCESS',
 *             todo: response.todo,
 *           }));
 *         },
 *         onError: (action: GetTodo, error: any) => {
 *           // dispatch an undo action to undo the changes in the client state
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
 *
 * In addition, if there are multiple requests for Todo 1 scheduled, it will only run the last one.
 *
 * @param opts
 */
export function fetch(opts) {
    return (source) => {
        if (opts.id) {
            const groupedFetches = source.pipe(mapActionAndState(), groupBy(([action, ...store]) => {
                return opts.id(action, ...store);
            }));
            return groupedFetches.pipe(mergeMap((pairs) => pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)))));
        }
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 * @whatItDoes Handles data fetching as part of router navigation.
 *
 * Data fetching implemented naively suffers from race conditions and poor error handling.
 *
 * `navigation` addresses these problems.
 *
 * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
 * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
 * the last request.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   loadTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       // listens for the routerNavigation action from @ngrx/router-store
 *       navigation(TodoComponent, {
 *         run: (activatedRouteSnapshot: ActivatedRouteSnapshot) => {
 *           return this.backend
 *             .fetchTodo(activatedRouteSnapshot.params['id'])
 *             .pipe(
 *               map((todo) => ({
 *                 type: 'LOAD_TODO_SUCCESS',
 *                 todo: todo,
 *               }))
 *             );
 *         },
 *         onError: (
 *           activatedRouteSnapshot: ActivatedRouteSnapshot,
 *           error: any
 *         ) => {
 *           // we can log and error here and return null
 *           // we can also navigate back
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * @param component
 * @param opts
 */
export function navigation(component, opts) {
    return (source) => {
        const nav = source.pipe(mapActionAndState(), filter(([action]) => isStateSnapshot(action)), map(([action, ...slices]) => {
            if (!isStateSnapshot(action)) {
                // Because of the above filter we'll never get here,
                // but this properly type narrows `action`
                return;
            }
            return [
                findSnapshot(component, action.payload.routerState.root),
                ...slices,
            ];
        }), filter(([snapshot]) => !!snapshot));
        return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
function isStateSnapshot(action) {
    return action.type === ROUTER_NAVIGATION;
}
function runWithErrorHandling(run, onError) {
    return ([action, ...slices]) => {
        try {
            const r = wrapIntoObservable(run(action, ...slices));
            return r.pipe(catchError((e) => wrapIntoObservable(onError(action, e))));
        }
        catch (e) {
            return wrapIntoObservable(onError(action, e));
        }
    };
}
/**
 * @whatItDoes maps Observable<Action | [Action, State]> to
 * Observable<[Action, State]>
 */
function mapActionAndState() {
    return (source) => {
        return source.pipe(map((value) => normalizeActionAndState(value)));
    };
}
/**
 * @whatItDoes Normalizes either a bare action or an array of action and slices
 * into an array of action and slices (or undefined)
 */
function normalizeActionAndState(args) {
    let action, slices;
    if (args instanceof Array) {
        [action, ...slices] = args;
    }
    else {
        slices = [];
        action = args;
    }
    return [action, ...slices];
}
function findSnapshot(component, s) {
    if (s.routeConfig && s.routeConfig.component === component) {
        return s;
    }
    for (const c of s.children) {
        const ss = findSnapshot(component, c);
        if (ss) {
            return ss;
        }
    }
    return null;
}
function wrapIntoObservable(obj) {
    if (isObservable(obj)) {
        return obj;
    }
    else if (!obj) {
        return of();
    }
    else {
        return of(obj);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1wZXJzaXN0ZW5jZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FuZ3VsYXIvc3JjL3J1bnRpbWUvbngvZGF0YS1wZXJzaXN0ZW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUd2RCxPQUFPLEVBQUUsWUFBWSxFQUFFLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN4QyxPQUFPLEVBQ0wsVUFBVSxFQUNWLFNBQVMsRUFDVCxNQUFNLEVBQ04sT0FBTyxFQUNQLEdBQUcsRUFDSCxRQUFRLEVBQ1IsU0FBUyxHQUNWLE1BQU0sZ0JBQWdCLENBQUM7QUFxQ3hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdERztBQUNILE1BQU0sVUFBVSxpQkFBaUIsQ0FDL0IsSUFBaUM7SUFFakMsT0FBTyxDQUFDLE1BQWdDLEVBQXNCLEVBQUU7UUFDOUQsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUNoQixpQkFBaUIsRUFBRSxFQUNuQixTQUFTLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FDeEQsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeURHO0FBQ0gsTUFBTSxVQUFVLGdCQUFnQixDQUM5QixJQUFnQztJQUVoQyxPQUFPLENBQUMsTUFBZ0MsRUFBc0IsRUFBRTtRQUM5RCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQ2hCLGlCQUFpQixFQUFFLEVBQ25CLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMs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QUUsQ0FBQyxDQUFDLENBQUM7UUFDdEMsSUFBSSxFQUFFLEVBQUU7WUFDTixPQUFPLEVBQUUsQ0FBQztTQUNYO0tBQ0Y7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFFRCxTQUFTLGtCQUFrQixDQUFJLEdBQTZCO0lBQzFELElBQUksWUFBWSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3JCLE9BQU8sR0FBRyxDQUFDO0tBQ1o7U0FBTSxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ2YsT0FBTyxFQUFFLEVBQUUsQ0FBQztLQUNiO1NBQU07UUFDTCxPQUFPLEVBQUUsQ0FBQyxHQUFRLENBQUMsQ0FBQztLQUNyQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB0eXBlIHtcbiAgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCxcbiAgUm91dGVyU3RhdGVTbmFwc2hvdCxcbn0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB0eXBlIHsgUm91dGVyTmF2aWdhdGlvbkFjdGlvbiB9IGZyb20gJ0BuZ3J4L3JvdXRlci1zdG9yZSc7XG5pbXBvcnQgeyBST1VURVJfTkFWSUdBVElPTiB9IGZyb20gJ0BuZ3J4L3JvdXRlci1zdG9yZSc7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbiB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcbmltcG9ydCB0eXBlIHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgaXNPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgY2F0Y2hFcnJvcixcbiAgY29uY2F0TWFwLFxuICBmaWx0ZXIsXG4gIGdyb3VwQnksXG4gIG1hcCxcbiAgbWVyZ2VNYXAsXG4gIHN3aXRjaE1hcCxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBlc3NpbWlzdGljVXBkYXRlT3B0czxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEE+IHtcbiAgcnVuKGE6IEEsIC4uLnNsaWNlczogWy4uLlRdKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgb25FcnJvcihhOiBBLCBlOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4gfCBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBPiB7XG4gIHJ1bihhOiBBLCAuLi5zbGljZXM6IFsuLi5UXSk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIHVuZG9BY3Rpb24oYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoT3B0czxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEE+IHtcbiAgaWQ/KGE6IEEsIC4uLnNsaWNlczogWy4uLlRdKTogYW55O1xuICBydW4oYTogQSwgLi4uc2xpY2VzOiBbLi4uVF0pOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICBvbkVycm9yPyhhOiBBLCBlOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4gfCBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFuZGxlTmF2aWdhdGlvbk9wdHM8VCBleHRlbmRzIEFycmF5PHVua25vd24+PiB7XG4gIHJ1bihcbiAgICBhOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LFxuICAgIC4uLnNsaWNlczogWy4uLlRdXG4gICk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIG9uRXJyb3I/KGE6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cblxuZXhwb3J0IHR5cGUgQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGVzPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQT4gPVxuICB8IEFcbiAgfCBbQSwgLi4uVF07XG5leHBvcnQgdHlwZSBBY3Rpb25PckFjdGlvbldpdGhTdGF0ZTxULCBBPiA9IEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlczxbVF0sIEE+O1xuZXhwb3J0IHR5cGUgQWN0aW9uU3RhdGVzU3RyZWFtPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQT4gPSBPYnNlcnZhYmxlPFxuICBBY3Rpb25PckFjdGlvbldpdGhTdGF0ZXM8VCwgQT5cbj47XG5leHBvcnQgdHlwZSBBY3Rpb25TdGF0ZVN0cmVhbTxULCBBPiA9IE9ic2VydmFibGU8XG4gIEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlczxbVF0sIEE+XG4+O1xuXG4vKipcbiAqXG4gKiBAd2hhdEl0RG9lcyBIYW5kbGVzIHBlc3NpbWlzdGljIHVwZGF0ZXMgKHVwZGF0aW5nIHRoZSBzZXJ2ZXIgZmlyc3QpLlxuICpcbiAqIFVwZGF0aW5nIHRoZSBzZXJ2ZXIsIHdoZW4gaW1wbGVtZW50ZWQgbmFpdmVseSwgc3VmZmVycyBmcm9tIHJhY2UgY29uZGl0aW9ucyBhbmQgcG9vciBlcnJvciBoYW5kbGluZy5cbiAqXG4gKiBgcGVzc2ltaXN0aWNVcGRhdGVgIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy4gSXQgcnVucyBhbGwgZmV0Y2hlcyBpbiBvcmRlciwgd2hpY2ggcmVtb3ZlcyByYWNlIGNvbmRpdGlvbnNcbiAqIGFuZCBmb3JjZXMgdGhlIGRldmVsb3BlciB0byBoYW5kbGUgZXJyb3JzLlxuICpcbiAqICMjIEV4YW1wbGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQEluamVjdGFibGUoKVxuICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICogICB1cGRhdGVUb2RvJCA9IGNyZWF0ZUVmZmVjdCgoKSA9PlxuICogICAgIHRoaXMuYWN0aW9ucyQucGlwZShcbiAqICAgICAgIG9mVHlwZSgnVVBEQVRFX1RPRE8nKSxcbiAqICAgICAgIHBlc3NpbWlzdGljVXBkYXRlKHtcbiAqICAgICAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uXG4gKiAgICAgICAgIHJ1bjogKGFjdGlvbjogVXBkYXRlVG9kbykgPT4ge1xuICogICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYmFja2VuZCBmaXJzdCwgYW5kIHRoZW4gZGlzcGF0Y2ggYW4gYWN0aW9uIHRoYXQgd2lsbFxuICogICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgY2xpZW50IHNpZGVcbiAqICAgICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLnVwZGF0ZVRvZG8oYWN0aW9uLnRvZG8uaWQsIGFjdGlvbi50b2RvKS5waXBlKFxuICogICAgICAgICAgICAgbWFwKCh1cGRhdGVkKSA9PiAoe1xuICogICAgICAgICAgICAgICB0eXBlOiAnVVBEQVRFX1RPRE9fU1VDQ0VTUycsXG4gKiAgICAgICAgICAgICAgIHRvZG86IHVwZGF0ZWQsXG4gKiAgICAgICAgICAgICB9KSlcbiAqICAgICAgICAgICApO1xuICogICAgICAgICB9LFxuICogICAgICAgICBvbkVycm9yOiAoYWN0aW9uOiBVcGRhdGVUb2RvLCBlcnJvcjogYW55KSA9PiB7XG4gKiAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byB1bmRvIHRoZSBjaGFuZ2VzIG9uIHRoZSBjbGllbnQgc2lkZS5cbiAqICAgICAgICAgICAvLyB3ZSBjYW4gZGlzcGF0Y2ggYW4gZXJyb3IsIG9yIHNpbXBseSBsb2cgdGhlIGVycm9yIGhlcmUgYW5kIHJldHVybiBgbnVsbGBcbiAqICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAqICAgICAgICAgfSxcbiAqICAgICAgIH0pXG4gKiAgICAgKVxuICogICApO1xuICpcbiAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBhY3Rpb25zJDogQWN0aW9ucywgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICogfVxuICogYGBgXG4gKlxuICogTm90ZSB0aGF0IGlmIHlvdSBkb24ndCByZXR1cm4gYSBuZXcgYWN0aW9uIGZyb20gdGhlIHJ1biBjYWxsYmFjaywgeW91IG11c3Qgc2V0IHRoZSBkaXNwYXRjaCBwcm9wZXJ0eVxuICogb2YgdGhlIGVmZmVjdCB0byBmYWxzZSwgbGlrZSB0aGlzOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAqICAgdXBkYXRlVG9kbyQgPSBjcmVhdGVFZmZlY3QoKCkgPT5cbiAqICAgICB0aGlzLmFjdGlvbnMkLnBpcGUoXG4gKiAgICAgICAvLy4uLlxuICogICAgICksIHsgZGlzcGF0Y2g6IGZhbHNlIH1cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZXNzaW1pc3RpY1VwZGF0ZTxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBvcHRzOiBQZXNzaW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVzU3RyZWFtPFQsIEE+KTogT2JzZXJ2YWJsZTxBY3Rpb24+ID0+IHtcbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgY29uY2F0TWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICpcbiAqIEB3aGF0SXREb2VzIEhhbmRsZXMgb3B0aW1pc3RpYyB1cGRhdGVzICh1cGRhdGluZyB0aGUgY2xpZW50IGZpcnN0KS5cbiAqXG4gKiBJdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9ucyBhbmQgZm9yY2VzIHRoZSBkZXZlbG9wZXIgdG8gaGFuZGxlIGVycm9ycy5cbiAqXG4gKiBXaGVuIHVzaW5nIGBvcHRpbWlzdGljVXBkYXRlYCwgaW4gY2FzZSBvZiBhIGZhaWx1cmUsIHRoZSBkZXZlbG9wZXIgaGFzIGFscmVhZHkgdXBkYXRlZCB0aGUgc3RhdGUgbG9jYWxseSxcbiAqIHNvIHRoZSBkZXZlbG9wZXIgbXVzdCBwcm92aWRlIGFuIHVuZG8gYWN0aW9uLlxuICpcbiAqIFRoZSBlcnJvciBoYW5kbGluZyBtdXN0IGJlIGRvbmUgaW4gdGhlIGNhbGxiYWNrLCBvciBieSBtZWFucyBvZiB0aGUgdW5kbyBhY3Rpb24uXG4gKlxuICogIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gKiAgIHVwZGF0ZVRvZG8kID0gY3JlYXRlRWZmZWN0KCgpID0+XG4gKiAgICAgdGhpcy5hY3Rpb25zJC5waXBlKFxuICogICAgICAgb2ZUeXBlKCdVUERBVEVfVE9ETycpLFxuICogICAgICAgb3B0aW1pc3RpY1VwZGF0ZSh7XG4gKiAgICAgICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvblxuICogICAgICAgICBydW46IChhY3Rpb246IFVwZGF0ZVRvZG8pID0+IHtcbiAqICAgICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLnVwZGF0ZVRvZG8oYWN0aW9uLnRvZG8uaWQsIGFjdGlvbi50b2RvKS5waXBlKFxuICogICAgICAgICAgICAgbWFwVG8oe1xuICogICAgICAgICAgICAgICB0eXBlOiAnVVBEQVRFX1RPRE9fU1VDQ0VTUycsXG4gKiAgICAgICAgICAgICB9KVxuICogICAgICAgICAgICk7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHVuZG9BY3Rpb246IChhY3Rpb246IFVwZGF0ZVRvZG8sIGVycm9yOiBhbnkpID0+IHtcbiAqICAgICAgICAgICAvLyBkaXNwYXRjaCBhbiB1bmRvIGFjdGlvbiB0byB1bmRvIHRoZSBjaGFuZ2VzIGluIHRoZSBjbGllbnQgc3RhdGVcbiAqICAgICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgICAgdHlwZTogJ1VORE9fVE9ET19VUERBVEUnLFxuICogICAgICAgICAgICAgdG9kbzogYWN0aW9uLnRvZG8sXG4gKiAgICAgICAgICAgfTtcbiAqICAgICAgICAgfSxcbiAqICAgICAgIH0pXG4gKiAgICAgKVxuICogICApO1xuICpcbiAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBhY3Rpb25zJDogQWN0aW9ucywgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICogfVxuICogYGBgXG4gKlxuICogTm90ZSB0aGF0IGlmIHlvdSBkb24ndCByZXR1cm4gYSBuZXcgYWN0aW9uIGZyb20gdGhlIHJ1biBjYWxsYmFjaywgeW91IG11c3Qgc2V0IHRoZSBkaXNwYXRjaCBwcm9wZXJ0eVxuICogb2YgdGhlIGVmZmVjdCB0byBmYWxzZSwgbGlrZSB0aGlzOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAqICAgdXBkYXRlVG9kbyQgPSBjcmVhdGVFZmZlY3QoKCkgPT5cbiAqICAgICB0aGlzLmFjdGlvbnMkLnBpcGUoXG4gKiAgICAgICAvLy4uLlxuICogICAgICksIHsgZGlzcGF0Y2g6IGZhbHNlIH1cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWlzdGljVXBkYXRlPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQSBleHRlbmRzIEFjdGlvbj4oXG4gIG9wdHM6IE9wdGltaXN0aWNVcGRhdGVPcHRzPFQsIEE+XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlc1N0cmVhbTxULCBBPik6IE9ic2VydmFibGU8QWN0aW9uPiA9PiB7XG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgIGNvbmNhdE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy51bmRvQWN0aW9uKSlcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqXG4gKiBAd2hhdEl0RG9lcyBIYW5kbGVzIGRhdGEgZmV0Y2hpbmcuXG4gKlxuICogRGF0YSBmZXRjaGluZyBpbXBsZW1lbnRlZCBuYWl2ZWx5IHN1ZmZlcnMgZnJvbSByYWNlIGNvbmRpdGlvbnMgYW5kIHBvb3IgZXJyb3IgaGFuZGxpbmcuXG4gKlxuICogYGZldGNoYCBhZGRyZXNzZXMgdGhlc2UgcHJvYmxlbXMuIEl0IHJ1bnMgYWxsIGZldGNoZXMgaW4gb3JkZXIsIHdoaWNoIHJlbW92ZXMgcmFjZSBjb25kaXRpb25zXG4gKiBhbmQgZm9yY2VzIHRoZSBkZXZlbG9wZXIgdG8gaGFuZGxlIGVycm9ycy5cbiAqXG4gKiAjIyBFeGFtcGxlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBJbmplY3RhYmxlKClcbiAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAqICAgbG9hZFRvZG9zJCA9IGNyZWF0ZUVmZmVjdCgoKSA9PlxuICogICAgIHRoaXMuYWN0aW9ucyQucGlwZShcbiAqICAgICAgIG9mVHlwZSgnR0VUX1RPRE9TJyksXG4gKiAgICAgICBmZXRjaCh7XG4gKiAgICAgICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvblxuICogICAgICAgICBydW46IChhOiBHZXRUb2RvcykgPT4ge1xuICogICAgICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZ2V0QWxsKCkucGlwZShcbiAqICAgICAgICAgICAgIG1hcCgocmVzcG9uc2UpID0+ICh7XG4gKiAgICAgICAgICAgICAgIHR5cGU6ICdUT0RPUycsXG4gKiAgICAgICAgICAgICAgIHRvZG9zOiByZXNwb25zZS50b2RvcyxcbiAqICAgICAgICAgICAgIH0pKVxuICogICAgICAgICAgICk7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIG9uRXJyb3I6IChhY3Rpb246IEdldFRvZG9zLCBlcnJvcjogYW55KSA9PiB7XG4gKiAgICAgICAgICAgLy8gZGlzcGF0Y2ggYW4gdW5kbyBhY3Rpb24gdG8gdW5kbyB0aGUgY2hhbmdlcyBpbiB0aGUgY2xpZW50IHN0YXRlXG4gKiAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICB9KVxuICogICAgIClcbiAqICAgKTtcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYWN0aW9ucyQ6IEFjdGlvbnMsIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgaXMgY29ycmVjdCwgYnV0IGJlY2F1c2UgaXQgc2V0IHRoZSBjb25jdXJyZW5jeSB0byAxLCBpdCBtYXkgbm90IGJlIHBlcmZvcm1hbnQuXG4gKlxuICogVG8gZml4IHRoYXQsIHlvdSBjYW4gcHJvdmlkZSB0aGUgYGlkYCBmdW5jdGlvbiwgbGlrZSB0aGlzOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBJbmplY3RhYmxlKClcbiAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAqICAgbG9hZFRvZG8kID0gY3JlYXRlRWZmZWN0KCgpID0+XG4gKiAgICAgdGhpcy5hY3Rpb25zJC5waXBlKFxuICogICAgICAgb2ZUeXBlKCdHRVRfVE9ETycpLFxuICogICAgICAgZmV0Y2goe1xuICogICAgICAgICBpZDogKHRvZG86IEdldFRvZG8pID0+IHtcbiAqICAgICAgICAgICByZXR1cm4gdG9kby5pZDtcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uXG4gKiAgICAgICAgIHJ1bjogKHRvZG86IEdldFRvZG8pID0+IHtcbiAqICAgICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmdldFRvZG8odG9kby5pZCkubWFwKChyZXNwb25zZSkgPT4gKHtcbiAqICAgICAgICAgICAgIHR5cGU6ICdMT0FEX1RPRE9fU1VDQ0VTUycsXG4gKiAgICAgICAgICAgICB0b2RvOiByZXNwb25zZS50b2RvLFxuICogICAgICAgICAgIH0pKTtcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgb25FcnJvcjogKGFjdGlvbjogR2V0VG9kbywgZXJyb3I6IGFueSkgPT4ge1xuICogICAgICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICogICAgICAgICAgIHJldHVybiBudWxsO1xuICogICAgICAgICB9LFxuICogICAgICAgfSlcbiAqICAgICApXG4gKiAgICk7XG4gKlxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFjdGlvbnMkOiBBY3Rpb25zLCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXaXRoIHRoaXMgc2V0dXAsIHRoZSByZXF1ZXN0cyBmb3IgVG9kbyAxIHdpbGwgcnVuIGNvbmN1cnJlbnRseSB3aXRoIHRoZSByZXF1ZXN0cyBmb3IgVG9kbyAyLlxuICpcbiAqIEluIGFkZGl0aW9uLCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgcmVxdWVzdHMgZm9yIFRvZG8gMSBzY2hlZHVsZWQsIGl0IHdpbGwgb25seSBydW4gdGhlIGxhc3Qgb25lLlxuICpcbiAqIEBwYXJhbSBvcHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaDxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBvcHRzOiBGZXRjaE9wdHM8VCwgQT5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVzU3RyZWFtPFQsIEE+KTogT2JzZXJ2YWJsZTxBY3Rpb24+ID0+IHtcbiAgICBpZiAob3B0cy5pZCkge1xuICAgICAgY29uc3QgZ3JvdXBlZEZldGNoZXMgPSBzb3VyY2UucGlwZShcbiAgICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgICAgZ3JvdXBCeSgoW2FjdGlvbiwgLi4uc3RvcmVdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9wdHMuaWQoYWN0aW9uLCAuLi5zdG9yZSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZ3JvdXBlZEZldGNoZXMucGlwZShcbiAgICAgICAgbWVyZ2VNYXAoKHBhaXJzKSA9PlxuICAgICAgICAgIHBhaXJzLnBpcGUoc3dpdGNoTWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgY29uY2F0TWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogQHdoYXRJdERvZXMgSGFuZGxlcyBkYXRhIGZldGNoaW5nIGFzIHBhcnQgb2Ygcm91dGVyIG5hdmlnYXRpb24uXG4gKlxuICogRGF0YSBmZXRjaGluZyBpbXBsZW1lbnRlZCBuYWl2ZWx5IHN1ZmZlcnMgZnJvbSByYWNlIGNvbmRpdGlvbnMgYW5kIHBvb3IgZXJyb3IgaGFuZGxpbmcuXG4gKlxuICogYG5hdmlnYXRpb25gIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy5cbiAqXG4gKiBJdCBjaGVja3MgaWYgYW4gYWN0aXZhdGVkIHJvdXRlciBzdGF0ZSBjb250YWlucyB0aGUgcGFzc2VkIGluIGNvbXBvbmVudCB0eXBlLCBhbmQsIGlmIGl0IGRvZXMsIHJ1bnMgdGhlIGBydW5gXG4gKiBjYWxsYmFjay4gSXQgcHJvdmlkZXMgdGhlIGFjdGl2YXRlZCBzbmFwc2hvdCBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbXBvbmVudCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUuIEFuZCBpdCBvbmx5IHJ1bnNcbiAqIHRoZSBsYXN0IHJlcXVlc3QuXG4gKlxuICogIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gKiAgIGxvYWRUb2RvJCA9IGNyZWF0ZUVmZmVjdCgoKSA9PlxuICogICAgIHRoaXMuYWN0aW9ucyQucGlwZShcbiAqICAgICAgIC8vIGxpc3RlbnMgZm9yIHRoZSByb3V0ZXJOYXZpZ2F0aW9uIGFjdGlvbiBmcm9tIEBuZ3J4L3JvdXRlci1zdG9yZVxuICogICAgICAgbmF2aWdhdGlvbihUb2RvQ29tcG9uZW50LCB7XG4gKiAgICAgICAgIHJ1bjogKGFjdGl2YXRlZFJvdXRlU25hcHNob3Q6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QpID0+IHtcbiAqICAgICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kXG4gKiAgICAgICAgICAgICAuZmV0Y2hUb2RvKGFjdGl2YXRlZFJvdXRlU25hcHNob3QucGFyYW1zWydpZCddKVxuICogICAgICAgICAgICAgLnBpcGUoXG4gKiAgICAgICAgICAgICAgIG1hcCgodG9kbykgPT4gKHtcbiAqICAgICAgICAgICAgICAgICB0eXBlOiAnTE9BRF9UT0RPX1NVQ0NFU1MnLFxuICogICAgICAgICAgICAgICAgIHRvZG86IHRvZG8sXG4gKiAgICAgICAgICAgICAgIH0pKVxuICogICAgICAgICAgICAgKTtcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgb25FcnJvcjogKFxuICogICAgICAgICAgIGFjdGl2YXRlZFJvdXRlU25hcHNob3Q6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsXG4gKiAgICAgICAgICAgZXJyb3I6IGFueVxuICogICAgICAgICApID0+IHtcbiAqICAgICAgICAgICAvLyB3ZSBjYW4gbG9nIGFuZCBlcnJvciBoZXJlIGFuZCByZXR1cm4gbnVsbFxuICogICAgICAgICAgIC8vIHdlIGNhbiBhbHNvIG5hdmlnYXRlIGJhY2tcbiAqICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAqICAgICAgICAgfSxcbiAqICAgICAgIH0pXG4gKiAgICAgKVxuICogICApO1xuICpcbiAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBhY3Rpb25zJDogQWN0aW9ucywgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICogQHBhcmFtIG9wdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hdmlnYXRpb248VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBIGV4dGVuZHMgQWN0aW9uPihcbiAgY29tcG9uZW50OiBUeXBlPGFueT4sXG4gIG9wdHM6IEhhbmRsZU5hdmlnYXRpb25PcHRzPFQ+XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlc1N0cmVhbTxULCBBPikgPT4ge1xuICAgIGNvbnN0IG5hdiA9IHNvdXJjZS5waXBlKFxuICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgIGZpbHRlcigoW2FjdGlvbl0pID0+IGlzU3RhdGVTbmFwc2hvdChhY3Rpb24pKSxcbiAgICAgIG1hcCgoW2FjdGlvbiwgLi4uc2xpY2VzXSkgPT4ge1xuICAgICAgICBpZiAoIWlzU3RhdGVTbmFwc2hvdChhY3Rpb24pKSB7XG4gICAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGUgYWJvdmUgZmlsdGVyIHdlJ2xsIG5ldmVyIGdldCBoZXJlLFxuICAgICAgICAgIC8vIGJ1dCB0aGlzIHByb3Blcmx5IHR5cGUgbmFycm93cyBgYWN0aW9uYFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZmluZFNuYXBzaG90KGNvbXBvbmVudCwgYWN0aW9uLnBheWxvYWQucm91dGVyU3RhdGUucm9vdCksXG4gICAgICAgICAgLi4uc2xpY2VzLFxuICAgICAgICBdIGFzIFtBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCAuLi5UXTtcbiAgICAgIH0pLFxuICAgICAgZmlsdGVyKChbc25hcHNob3RdKSA9PiAhIXNuYXBzaG90KVxuICAgICk7XG5cbiAgICByZXR1cm4gbmF2LnBpcGUoc3dpdGNoTWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGVTbmFwc2hvdChcbiAgYWN0aW9uOiBhbnlcbik6IGFjdGlvbiBpcyBSb3V0ZXJOYXZpZ2F0aW9uQWN0aW9uPFJvdXRlclN0YXRlU25hcHNob3Q+IHtcbiAgcmV0dXJuIGFjdGlvbi50eXBlID09PSBST1VURVJfTkFWSUdBVElPTjtcbn1cblxuZnVuY3Rpb24gcnVuV2l0aEVycm9ySGFuZGxpbmc8VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBLCBSPihcbiAgcnVuOiAoYTogQSwgLi4uc2xpY2VzOiBbLi4uVF0pID0+IE9ic2VydmFibGU8Uj4gfCBSIHwgdm9pZCxcbiAgb25FcnJvcjogYW55XG4pIHtcbiAgcmV0dXJuIChbYWN0aW9uLCAuLi5zbGljZXNdOiBbQSwgLi4uVF0pOiBPYnNlcnZhYmxlPFI+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgciA9IHdyYXBJbnRvT2JzZXJ2YWJsZShydW4oYWN0aW9uLCAuLi5zbGljZXMpKTtcbiAgICAgIHJldHVybiByLnBpcGUoY2F0Y2hFcnJvcigoZSkgPT4gd3JhcEludG9PYnNlcnZhYmxlKG9uRXJyb3IoYWN0aW9uLCBlKSkpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gd3JhcEludG9PYnNlcnZhYmxlKG9uRXJyb3IoYWN0aW9uLCBlKSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEB3aGF0SXREb2VzIG1hcHMgT2JzZXJ2YWJsZTxBY3Rpb24gfCBbQWN0aW9uLCBTdGF0ZV0+IHRvXG4gKiBPYnNlcnZhYmxlPFtBY3Rpb24sIFN0YXRlXT5cbiAqL1xuZnVuY3Rpb24gbWFwQWN0aW9uQW5kU3RhdGU8VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBPigpIHtcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8QWN0aW9uT3JBY3Rpb25XaXRoU3RhdGVzPFQsIEE+PikgPT4ge1xuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcCgodmFsdWUpID0+IG5vcm1hbGl6ZUFjdGlvbkFuZFN0YXRlKHZhbHVlKSBhcyBbQSwgLi4uVF0pXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBOb3JtYWxpemVzIGVpdGhlciBhIGJhcmUgYWN0aW9uIG9yIGFuIGFycmF5IG9mIGFjdGlvbiBhbmQgc2xpY2VzXG4gKiBpbnRvIGFuIGFycmF5IG9mIGFjdGlvbiBhbmQgc2xpY2VzIChvciB1bmRlZmluZWQpXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFjdGlvbkFuZFN0YXRlPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQT4oXG4gIGFyZ3M6IEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlczxULCBBPlxuKTogW0EsIC4uLlRdIHtcbiAgbGV0IGFjdGlvbjogQSwgc2xpY2VzOiBUO1xuXG4gIGlmIChhcmdzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBbYWN0aW9uLCAuLi5zbGljZXNdID0gYXJncztcbiAgfSBlbHNlIHtcbiAgICBzbGljZXMgPSBbXSBhcyBUO1xuICAgIGFjdGlvbiA9IGFyZ3M7XG4gIH1cblxuICByZXR1cm4gW2FjdGlvbiwgLi4uc2xpY2VzXTtcbn1cblxuZnVuY3Rpb24gZmluZFNuYXBzaG90KFxuICBjb21wb25lbnQ6IFR5cGU8YW55PixcbiAgczogQWN0aXZhdGVkUm91dGVTbmFwc2hvdFxuKTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB7XG4gIGlmIChzLnJvdXRlQ29uZmlnICYmIHMucm91dGVDb25maWcuY29tcG9uZW50ID09PSBjb21wb25lbnQpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuICBmb3IgKGNvbnN0IGMgb2Ygcy5jaGlsZHJlbikge1xuICAgIGNvbnN0IHNzID0gZmluZFNuYXBzaG90KGNvbXBvbmVudCwgYyk7XG4gICAgaWYgKHNzKSB7XG4gICAgICByZXR1cm4gc3M7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB3cmFwSW50b09ic2VydmFibGU8Tz4ob2JqOiBPYnNlcnZhYmxlPE8+IHwgTyB8IHZvaWQpOiBPYnNlcnZhYmxlPE8+IHtcbiAgaWYgKGlzT2JzZXJ2YWJsZShvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIGlmICghb2JqKSB7XG4gICAgcmV0dXJuIG9mKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9mKG9iaiBhcyBPKTtcbiAgfVxufVxuIl19