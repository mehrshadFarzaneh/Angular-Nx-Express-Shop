"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFiles = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
function createFiles(tree, options) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    const filesFolder = options.setupFile === 'angular' ? '../files-angular' : '../files';
    let transformer;
    let transformerOptions = null;
    if (options.compiler === 'babel' || options.babelJest) {
        transformer = 'babel-jest';
    }
    else if (options.compiler === 'swc') {
        transformer = '@swc/jest';
        if (options.supportTsx) {
            transformerOptions =
                "{ jsc: { transform: { react: { runtime: 'automatic' } } } }";
        }
    }
    else {
        transformer = 'ts-jest';
        transformerOptions = "{ tsconfig: '<rootDir>/tsconfig.spec.json' }";
    }
    (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, filesFolder), projectConfig.root, Object.assign(Object.assign({ tmpl: '' }, options), { 
        // jsdom is the default
        testEnvironment: options.testEnvironment === 'none' || options.testEnvironment === 'jsdom'
            ? ''
            : options.testEnvironment, transformer,
        transformerOptions, js: !!options.js, rootProject: options.rootProject, projectRoot: options.rootProject ? options.project : projectConfig.root, offsetFromRoot: (0, devkit_1.offsetFromRoot)(projectConfig.root) }));
    if (options.setupFile === 'none') {
        tree.delete((0, path_1.join)(projectConfig.root, './src/test-setup.ts'));
    }
    if (options.babelJest && !tree.exists('babel.config.json')) {
        tree.write('babel.config.json', JSON.stringify({
            babelrcRoots: ['*'],
        }));
    }
    if (options.js) {
        tree.rename((0, path_1.join)(projectConfig.root, 'jest.config.ts'), (0, path_1.join)(projectConfig.root, 'jest.config.js'));
    }
}
exports.createFiles = createFiles;
