"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateDevRemotes = exports.getStaticRemotes = exports.getDynamicRemotes = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
function getDynamicRemotes(project, context, workspaceProjects, remotesToSkip, pathToManifestFile = (0, path_1.join)(context.workspaceRoot, project.sourceRoot, 'assets/module-federation.manifest.json')) {
    // check for dynamic remotes
    // we should only check for dynamic based on what we generate
    // and fallback to empty array
    if (!(0, fs_1.existsSync)(pathToManifestFile)) {
        return [];
    }
    const moduleFederationManifestJson = (0, fs_1.readFileSync)(pathToManifestFile, 'utf-8');
    if (!moduleFederationManifestJson) {
        return [];
    }
    // This should have shape of
    // {
    //   "remoteName": "remoteLocation",
    // }
    const parsedManifest = JSON.parse(moduleFederationManifestJson);
    if (!Object.keys(parsedManifest).every((key) => typeof key === 'string' && typeof parsedManifest[key] === 'string')) {
        return [];
    }
    const dynamicRemotes = Object.entries(parsedManifest)
        .map(([remoteName]) => remoteName)
        .filter((r) => !remotesToSkip.has(r));
    const invalidDynamicRemotes = dynamicRemotes.filter((remote) => !workspaceProjects[remote]);
    if (invalidDynamicRemotes.length) {
        throw new Error(invalidDynamicRemotes.length === 1
            ? `Invalid dynamic remote configured in "${pathToManifestFile}": ${invalidDynamicRemotes[0]}.`
            : `Invalid dynamic remotes configured in "${pathToManifestFile}": ${invalidDynamicRemotes.join(', ')}.`);
    }
    return dynamicRemotes;
}
exports.getDynamicRemotes = getDynamicRemotes;
function getStaticRemotes(project, context, workspaceProjects, remotesToSkip) {
    const mfConfigPath = (0, path_1.join)(context.workspaceRoot, project.root, 'module-federation.config.js');
    let mfeConfig;
    try {
        mfeConfig = require(mfConfigPath);
    }
    catch (_a) {
        throw new Error(`Could not load ${mfConfigPath}. Was this project generated with "@nx/angular:host"?`);
    }
    const remotesConfig = Array.isArray(mfeConfig.remotes) && mfeConfig.remotes.length > 0
        ? mfeConfig.remotes
        : [];
    const staticRemotes = remotesConfig
        .map((remoteDefinition) => Array.isArray(remoteDefinition) ? remoteDefinition[0] : remoteDefinition)
        .filter((r) => !remotesToSkip.has(r));
    const invalidStaticRemotes = staticRemotes.filter((remote) => !workspaceProjects[remote]);
    if (invalidStaticRemotes.length) {
        throw new Error(invalidStaticRemotes.length === 1
            ? `Invalid static remote configured in "${mfConfigPath}": ${invalidStaticRemotes[0]}.`
            : `Invalid static remotes configured in "${mfConfigPath}": ${invalidStaticRemotes.join(', ')}.`);
    }
    return staticRemotes;
}
exports.getStaticRemotes = getStaticRemotes;
function validateDevRemotes(options, workspaceProjects) {
    var _a;
    const invalidDevRemotes = (_a = options.devRemotes) === null || _a === void 0 ? void 0 : _a.filter((remote) => !workspaceProjects[remote]);
    if (invalidDevRemotes.length) {
        throw new Error(invalidDevRemotes.length === 1
            ? `Invalid dev remote provided: ${invalidDevRemotes[0]}.`
            : `Invalid dev remotes provided: ${invalidDevRemotes.join(', ')}.`);
    }
}
exports.validateDevRemotes = validateDevRemotes;
