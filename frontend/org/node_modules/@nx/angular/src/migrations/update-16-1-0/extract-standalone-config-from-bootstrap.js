"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const ensure_typescript_1 = require("@nx/js/src/utils/typescript/ensure-typescript");
const path_1 = require("path");
let tsModule;
let tsquery;
function getBootstrapCallFileInfo(tree, project, mainFilePath) {
    const IMPORT_BOOTSTRAP_FILE = 'CallExpression:has(ImportKeyword) > StringLiteral';
    let bootstrapCallFilePath = mainFilePath;
    let bootstrapCallFileContents = tree.read(bootstrapCallFilePath, 'utf-8');
    const ast = tsquery.ast(bootstrapCallFileContents);
    const importBootstrapNodes = tsquery(ast, IMPORT_BOOTSTRAP_FILE, {
        visitAllChildren: true,
    });
    if (importBootstrapNodes.length > 0 &&
        importBootstrapNodes[0].getText().includes('./bootstrap')) {
        bootstrapCallFilePath = (0, devkit_1.joinPathFragments)(project.sourceRoot, 'bootstrap.ts');
        bootstrapCallFileContents = tree.read(bootstrapCallFilePath, 'utf-8');
    }
    return { bootstrapCallFilePath, bootstrapCallFileContents };
}
function getImportTokenMap(bootstrapCallFileContentsAst) {
    const importTokenMap = new Map();
    const importedTokensNodes = tsquery(bootstrapCallFileContentsAst, 'ImportDeclaration > ImportClause', { visitAllChildren: true });
    for (const node of importedTokensNodes) {
        importTokenMap.set(node.getText(), node.parent.getText());
    }
    return importTokenMap;
}
function getImportsRequiredForAppConfig(importTokenMap, appConfigNode, oldSourceFilePath, newSourceFilePath) {
    const identifiers = tsquery.query(appConfigNode, 'Identifier:not(PropertyAssignment > Identifier)', { visitAllChildren: true });
    const appConfigImports = new Set();
    const originalImportsToRemove = new Set();
    for (const identifier of identifiers) {
        for (const key of importTokenMap.keys()) {
            if (!key.includes(identifier.getText())) {
                continue;
            }
            let importText = importTokenMap.get(key);
            originalImportsToRemove.add(importText);
            if (oldSourceFilePath === newSourceFilePath ||
                oldSourceFilePath.split('/').length ===
                    newSourceFilePath.split('/').length) {
                appConfigImports.add(importText);
                continue;
            }
            const importPath = tsquery
                .query(importText, 'StringLiteral', {
                visitAllChildren: true,
            })[0]
                .getText()
                .replace(/'/g, '')
                .replace(/"/g, '');
            if (importPath.startsWith('.')) {
                const resolvedImportPath = (0, path_1.resolve)((0, path_1.dirname)(oldSourceFilePath), importPath);
                const newRelativeImportPath = (0, path_1.relative)((0, path_1.dirname)(newSourceFilePath), resolvedImportPath);
                importText = importText.replace(importPath, newRelativeImportPath.startsWith('.')
                    ? newRelativeImportPath
                    : `./${newRelativeImportPath}`);
            }
            appConfigImports.add(importText);
        }
    }
    return {
        appConfigImports: Array.from(appConfigImports),
        importsToRemoveFromSource: Array.from(originalImportsToRemove),
    };
}
function getAppConfigFileContents(importsRequiredForAppConfig, appConfigText) {
    const buildAppConfigFileContents = (importStatements, appConfig) => `import { ApplicationConfig } from '@angular/core';${importStatements.join('\n')}
        export const appConfig: ApplicationConfig = ${appConfig}`;
    const appConfigFileContents = buildAppConfigFileContents(importsRequiredForAppConfig, appConfigText);
    return appConfigFileContents;
}
function getBootstrapCallFileContents(bootstrapCallFileContents, appConfigNode, importsRequiredForAppConfig) {
    let newBootstrapCallFileContents = `import { appConfig } from './app/app.config';
${bootstrapCallFileContents.slice(0, appConfigNode.getStart())}appConfig${bootstrapCallFileContents.slice(appConfigNode.getEnd())}`;
    for (const importStatement of importsRequiredForAppConfig) {
        newBootstrapCallFileContents = newBootstrapCallFileContents.replace(importStatement, '');
    }
    return newBootstrapCallFileContents;
}
function extractStandaloneConfig(tree) {
    var _a, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!tsModule) {
            tsModule = (0, ensure_typescript_1.ensureTypescript)();
        }
        if (!tsquery) {
            tsquery = require('@phenomnomnominal/tsquery').tsquery;
        }
        const projects = (0, devkit_1.getProjects)(tree);
        const BOOTSTRAP_APPLICATION_CALL_SELECTOR = 'CallExpression:has(Identifier[name=bootstrapApplication])';
        const BOOTSTRAP_APPLICATION_CALL_CONFIG_SELECTOR = 'CallExpression:has(Identifier[name=bootstrapApplication]) > ObjectLiteralExpression';
        for (const [, project] of projects.entries()) {
            if (project.projectType !== 'application') {
                continue;
            }
            if (((_c = (_b = (_a = project.targets) === null || _a === void 0 ? void 0 : _a.build) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.main) === undefined) {
                continue;
            }
            const { bootstrapCallFilePath, bootstrapCallFileContents } = getBootstrapCallFileInfo(tree, project, project.targets.build.options.main);
            const bootstrapCallFileContentsAst = tsquery.ast(bootstrapCallFileContents);
            const nodes = tsquery(bootstrapCallFileContentsAst, BOOTSTRAP_APPLICATION_CALL_SELECTOR, { visitAllChildren: true });
            if (nodes.length === 0) {
                continue;
            }
            const importTokenMap = getImportTokenMap(bootstrapCallFileContentsAst);
            const bootstrapCallNode = nodes[0];
            const appConfigNodes = tsquery(bootstrapCallNode, BOOTSTRAP_APPLICATION_CALL_CONFIG_SELECTOR, { visitAllChildren: true });
            if (appConfigNodes.length === 0) {
                continue;
            }
            const appConfigNode = appConfigNodes[0];
            const appConfigText = appConfigNode.getText();
            const appConfigFilePath = (0, devkit_1.joinPathFragments)(project.sourceRoot, 'app/app.config.ts');
            const { appConfigImports, importsToRemoveFromSource } = getImportsRequiredForAppConfig(importTokenMap, appConfigNode, bootstrapCallFilePath, appConfigFilePath);
            const appConfigFileContents = getAppConfigFileContents(appConfigImports, appConfigText);
            tree.write(appConfigFilePath, appConfigFileContents);
            let newBootstrapCallFileContents = getBootstrapCallFileContents(bootstrapCallFileContents, appConfigNode, importsToRemoveFromSource);
            tree.write(bootstrapCallFilePath, newBootstrapCallFileContents);
        }
        yield (0, devkit_1.formatFiles)(tree);
    });
}
exports.default = extractStandaloneConfig;
