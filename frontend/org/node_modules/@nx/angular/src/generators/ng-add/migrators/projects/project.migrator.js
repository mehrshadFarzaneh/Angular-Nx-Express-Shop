"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectMigrator = void 0;
const devkit_1 = require("@nx/devkit");
const utilities_1 = require("../../utilities");
const migrator_1 = require("../migrator");
class ProjectMigrator extends migrator_1.Migrator {
    get projectName() {
        return this.project.name;
    }
    constructor(tree, options, targets, project, rootDir, logger, 
    // TODO(leo): this will replace `targets` and become required once the full
    // refactor is done.
    supportedBuilderMigrators) {
        var _a, _b;
        super(tree, project.config, logger !== null && logger !== void 0 ? logger : new utilities_1.Logger(project.name));
        this.options = options;
        this.targets = targets;
        // TODO(leo): need to handle targets until all are converted to builder migrators,
        // at that point, project migrators only care about skipping the whole project migration
        // and each builder migrator will handle whether it should be skipped or not
        this.skipMigration = false;
        this.targetNames = {};
        this.project = {
            name: project.name,
            oldRoot: (_a = this.projectConfig.root) !== null && _a !== void 0 ? _a : '',
            oldSourceRoot: this.projectConfig.sourceRoot ||
                (0, devkit_1.joinPathFragments)((_b = this.projectConfig.root) !== null && _b !== void 0 ? _b : '', 'src'),
            newRoot: `${rootDir}/${project.name}`,
            newSourceRoot: `${rootDir}/${project.name}/src`,
        };
        this.collectTargetNames();
        this.createBuilderMigrators(supportedBuilderMigrators);
    }
    getWorkspaceRootFileTypesInfo() {
        var _a;
        const workspaceRootFileTypesInfo = {
            eslint: Boolean((_a = this.projectConfig.targets) === null || _a === void 0 ? void 0 : _a.lint) ||
                this.tree.exists(`${this.projectConfig.root}/.eslintrc.json`),
            karma: this.builderMigrators.some((migrator) => migrator.rootFileType === 'karma' && migrator.isBuilderUsed()),
        };
        return workspaceRootFileTypesInfo;
    }
    migrate() {
        const validationResult = this.validate();
        if (!validationResult) {
            return;
        }
        this.logger.warn((0, utilities_1.getProjectValidationResultMessage)(validationResult));
    }
    validate() {
        var _a, _b;
        const errors = [];
        // check project root
        if (this.projectConfig.root === undefined ||
            this.projectConfig.root === null) {
            errors.push({
                message: 'The project root is not defined in the project configuration. The project will be skipped.',
                hint: 'Make sure to manually migrate its configuration and files or remove the project if it is not valid. ' +
                    `Alternatively, you could revert the migration, ensure the value for "projects.${this.project.name}.root" ` +
                    'is set and run the migration again.',
            });
            this.skipProjectMigration();
        }
        else if (this.projectConfig.root !== '' &&
            !this.tree.exists(this.projectConfig.root)) {
            errors.push({
                message: `The project root "${this.project.oldRoot}" could not be found. The project will be skipped.`,
                hint: 'Make sure to manually migrate its configuration and files or remove the project if it is not valid. ' +
                    `Alternatively, you could revert the migration, ensure the value for "projects.${this.project.name}.root" ` +
                    'is correct and run the migration again.',
            });
            this.skipProjectMigration();
        }
        // check project source root
        if (this.projectConfig.sourceRoot &&
            !this.tree.exists(this.projectConfig.sourceRoot)) {
            errors.push({
                message: `The project source root "${this.project.oldSourceRoot}" could not be found. The project will be skipped.`,
                hint: 'Make sure to manually migrate its configuration and files or remove the project if it is not valid. ' +
                    `Alternatively, you could revert the migration, ensure the value for "projects.${this.project.name}.sourceRoot" ` +
                    'is correct and run the migration again.',
            });
            this.skipProjectMigration();
        }
        // check for usage of unsupported builders
        const allSupportedBuilders = [
            ...Object.values(this.targets)
                .map((x) => x.builders)
                .flat(),
        ];
        allSupportedBuilders.push(...this.builderMigrators.map((migrator) => migrator.builderName));
        const unsupportedBuilders = [];
        Object.entries((_a = this.projectConfig.targets) !== null && _a !== void 0 ? _a : {}).forEach(([targetName, target]) => {
            if (!allSupportedBuilders.includes(target.executor)) {
                unsupportedBuilders.push([targetName, target.executor]);
            }
        });
        if (unsupportedBuilders.length) {
            errors.push({
                messageGroup: {
                    title: 'Unsupported builders',
                    messages: unsupportedBuilders.map(([target, builder]) => `The "${target}" target is using a builder "${builder}" that's not currently supported by the automated migration. ` +
                        'The target will be skipped.'),
                },
                hint: 'Make sure to manually migrate the target configuration and any possible associated files. Alternatively, you could ' +
                    `revert the migration, change the builder to one of the builders supported by the automated migration (${(0, utilities_1.arrayToString)(allSupportedBuilders)}), and run the migration again.`,
            });
        }
        // check for multiple targets for the same type of target
        const targetTypes = Object.keys(this.targets);
        const targetsByType = Object.entries((_b = this.projectConfig.targets) !== null && _b !== void 0 ? _b : {}).reduce((acc, [target, { executor }]) => {
            targetTypes.forEach((targetType) => {
                if (this.targets[targetType].builders.includes(executor)) {
                    acc[targetType].push(target);
                    return acc;
                }
            });
            return acc;
        }, targetTypes.reduce((acc, targetType) => (Object.assign(Object.assign({}, acc), { [targetType]: [] })), {}));
        targetTypes.forEach((targetType) => {
            if (this.targets[targetType].acceptMultipleDefinitions ||
                targetsByType[targetType].length <= 1) {
                return;
            }
            errors.push({
                message: `There is more than one target using a builder that is used to ${targetType} the project (${(0, utilities_1.arrayToString)(targetsByType[targetType])}). This is not currently supported by the automated migration. These targets will be skipped.`,
                hint: 'Make sure to manually migrate their configuration and any possible associated files.',
            });
            this.skipTargetTypeMigration(targetType);
        });
        return errors.length ? errors : null;
    }
    convertPath(originalPath) {
        if (originalPath === null || originalPath === void 0 ? void 0 : originalPath.startsWith(this.project.oldSourceRoot)) {
            return (0, devkit_1.joinPathFragments)(this.project.newSourceRoot, originalPath.replace(this.project.oldSourceRoot, ''));
        }
        if (originalPath === null || originalPath === void 0 ? void 0 : originalPath.startsWith(this.project.oldRoot)) {
            return (0, devkit_1.joinPathFragments)(this.project.newRoot, originalPath.replace(this.project.oldRoot, ''));
        }
        return originalPath;
    }
    moveDir(from, to) {
        (0, devkit_1.visitNotIgnoredFiles)(this.tree, from, (file) => {
            this.moveFile(file, (0, devkit_1.normalizePath)(file).replace(from, to), true);
        });
    }
    shouldSkipTargetTypeMigration(targetType) {
        return (Array.isArray(this.skipMigration) &&
            this.skipMigration.includes(targetType));
    }
    collectTargetNames() {
        var _a;
        const targetTypes = Object.keys(this.targets);
        Object.entries((_a = this.projectConfig.targets) !== null && _a !== void 0 ? _a : {}).forEach(([targetName, target]) => {
            targetTypes.forEach((targetType) => {
                if (!this.targetNames[targetType] &&
                    this.targets[targetType].builders.includes(target.executor)) {
                    this.targetNames[targetType] = targetName;
                }
            });
        });
    }
    createBuilderMigrators(supportedBuilderMigrators) {
        if (!supportedBuilderMigrators) {
            this.builderMigrators = [];
            return;
        }
        this.builderMigrators = supportedBuilderMigrators.map((migratorClass) => new migratorClass(this.tree, this.project, this.projectConfig, this.logger));
    }
    skipProjectMigration() {
        this.skipMigration = true;
    }
    skipTargetTypeMigration(targetType) {
        if (this.skipMigration === true) {
            return;
        }
        if (!Array.isArray(this.skipMigration)) {
            this.skipMigration = [];
        }
        this.skipMigration.push(targetType);
    }
}
exports.ProjectMigrator = ProjectMigrator;
