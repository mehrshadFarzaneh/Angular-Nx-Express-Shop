"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jestInitSchematic = exports.jestInitGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const find_root_jest_files_1 = require("../../utils/config/find-root-jest-files");
const versions_1 = require("../../utils/versions");
const schemaDefaults = {
    compiler: 'tsc',
    js: false,
    rootProject: false,
    testEnvironment: 'jsdom',
};
function generateGlobalConfig(tree, isJS) {
    const contents = isJS
        ? (0, devkit_1.stripIndents) `
    const { getJestProjects } = require('@nx/jest');

    module.exports = {
      projects: getJestProjects()
    };`
        : (0, devkit_1.stripIndents) `
    import { getJestProjects } from '@nx/jest';

    export default {
     projects: getJestProjects()
    };`;
    tree.write(`jest.config.${isJS ? 'js' : 'ts'}`, contents);
}
function createJestConfig(tree, options) {
    var _a;
    if (!tree.exists('jest.preset.js')) {
        // preset is always js file.
        tree.write(`jest.preset.js`, `
      const nxPreset = require('@nx/jest/preset').default;

      module.exports = { ...nxPreset }`);
        addTestInputs(tree);
    }
    if (options.rootProject) {
        // we don't want any config to be made because the `jestProjectGenerator`
        // will copy the template config file
        return;
    }
    const rootJestPath = (0, find_root_jest_files_1.findRootJestConfig)(tree);
    if (!rootJestPath) {
        // if there's not root jest config, we will create one and return
        // this can happen when:
        // - root jest config was renamed => in which case there is migration needed
        // - root project didn't have jest setup => again, no migration is needed
        generateGlobalConfig(tree, options.js);
        return;
    }
    if (tree.exists(rootJestPath)) {
        // moving from root project config to monorepo-style config
        const projects = (0, devkit_1.getProjects)(tree);
        const projectNames = Array.from(projects.keys());
        const rootProject = projectNames.find((projectName) => { var _a; return ((_a = projects.get(projectName)) === null || _a === void 0 ? void 0 : _a.root) === '.'; });
        // root project might have been removed,
        // if it's missing there's nothing to migrate
        if (rootProject) {
            const rootProjectConfig = projects.get(rootProject);
            const jestTarget = Object.values(rootProjectConfig.targets || {}).find((t) => (t === null || t === void 0 ? void 0 : t.executor) === '@nx/jest:jest' || (t === null || t === void 0 ? void 0 : t.executor) === '@nrwl/jest:jest');
            const isProjectConfig = ((_a = jestTarget === null || jestTarget === void 0 ? void 0 : jestTarget.options) === null || _a === void 0 ? void 0 : _a.jestConfig) === rootJestPath;
            // if root project doesn't have jest target, there's nothing to migrate
            if (isProjectConfig) {
                const jestAppConfig = `jest.config.app.${options.js ? 'js' : 'ts'}`;
                tree.rename(rootJestPath, jestAppConfig);
                jestTarget.options.jestConfig = jestAppConfig;
                (0, devkit_1.updateProjectConfiguration)(tree, rootProject, rootProjectConfig);
            }
            // generate new global config as it was move to project config or is missing
            generateGlobalConfig(tree, options.js);
        }
    }
}
function addTestInputs(tree) {
    var _a, _b, _c, _d;
    var _e, _f;
    const nxJson = (0, devkit_1.readNxJson)(tree);
    const productionFileSet = (_a = nxJson.namedInputs) === null || _a === void 0 ? void 0 : _a.production;
    if (productionFileSet) {
        // This is one of the patterns in the default jest patterns
        productionFileSet.push(
        // Remove spec, test, and snapshots from the production fileset
        '!{projectRoot}/**/?(*.)+(spec|test).[jt]s?(x)?(.snap)', 
        // Remove tsconfig.spec.json
        '!{projectRoot}/tsconfig.spec.json', 
        // Remove jest.config.js/ts
        '!{projectRoot}/jest.config.[jt]s');
        // Dedupe and set
        nxJson.namedInputs.production = Array.from(new Set(productionFileSet));
    }
    // Test targets depend on all their project's sources + production sources of dependencies
    (_b = nxJson.targetDefaults) !== null && _b !== void 0 ? _b : (nxJson.targetDefaults = {});
    (_c = (_e = nxJson.targetDefaults).test) !== null && _c !== void 0 ? _c : (_e.test = {});
    (_d = (_f = nxJson.targetDefaults.test).inputs) !== null && _d !== void 0 ? _d : (_f.inputs = [
        'default',
        productionFileSet ? '^production' : '^default',
    ]);
    nxJson.targetDefaults.test.inputs.push('{workspaceRoot}/jest.preset.js');
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
function updateDependencies(tree, options) {
    const dependencies = {
        tslib: versions_1.tslibVersion,
    };
    const devDeps = {
        '@nx/jest': versions_1.nxVersion,
        jest: versions_1.jestVersion,
        // because the default jest-preset uses ts-jest,
        // jest will throw an error if it's not installed
        // even if not using it in overriding transformers
        'ts-jest': versions_1.tsJestVersion,
    };
    if (options.testEnvironment !== 'none') {
        devDeps[`jest-environment-${options.testEnvironment}`] = versions_1.jestVersion;
    }
    if (!options.js) {
        devDeps['ts-node'] = versions_1.tsNodeVersion;
        devDeps['@types/jest'] = versions_1.jestTypesVersion;
        devDeps['@types/node'] = versions_1.typesNodeVersion;
    }
    if (options.compiler === 'babel' || options.babelJest) {
        devDeps['babel-jest'] = versions_1.babelJestVersion;
        // in some cases @nx/js will not already be present i.e. node only projects
        devDeps['@nx/js'] = versions_1.nxVersion;
    }
    else if (options.compiler === 'swc') {
        devDeps['@swc/jest'] = versions_1.swcJestVersion;
    }
    return (0, devkit_1.addDependenciesToPackageJson)(tree, dependencies, devDeps);
}
function updateExtensions(host) {
    if (!host.exists('.vscode/extensions.json')) {
        return;
    }
    (0, devkit_1.updateJson)(host, '.vscode/extensions.json', (json) => {
        json.recommendations = json.recommendations || [];
        const extension = 'firsttris.vscode-jest-runner';
        if (!json.recommendations.includes(extension)) {
            json.recommendations.push(extension);
        }
        return json;
    });
}
function jestInitGenerator(tree, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const options = normalizeOptions(schema);
        const tasks = [];
        tasks.push(yield (0, js_1.initGenerator)(tree, Object.assign(Object.assign({}, schema), { skipFormat: true })));
        createJestConfig(tree, options);
        if (!options.skipPackageJson) {
            (0, devkit_1.removeDependenciesFromPackageJson)(tree, ['@nx/jest'], []);
            const installTask = updateDependencies(tree, options);
            tasks.push(installTask);
        }
        updateExtensions(tree);
        return (0, devkit_1.runTasksInSerial)(...tasks);
    });
}
exports.jestInitGenerator = jestInitGenerator;
function normalizeOptions(options) {
    return Object.assign(Object.assign({}, schemaDefaults), options);
}
exports.default = jestInitGenerator;
exports.jestInitSchematic = (0, devkit_1.convertNxGenerator)(jestInitGenerator);
