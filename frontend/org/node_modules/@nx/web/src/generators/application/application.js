"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applicationSchematic = exports.applicationGenerator = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const devkit_1 = require("@nx/devkit");
const versions_1 = require("@nx/js/src/utils/versions");
const js_1 = require("@nx/js");
const versions_2 = require("../../utils/versions");
const init_1 = require("../init/init");
function createApplicationFiles(tree, options) {
    (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, options.bundler === 'vite' ? './files/app-vite' : './files/app-webpack'), options.appProjectRoot, Object.assign(Object.assign(Object.assign({}, options), (0, devkit_1.names)(options.name)), { tmpl: '', offsetFromRoot: (0, devkit_1.offsetFromRoot)(options.appProjectRoot), rootTsConfigPath: (0, js_1.getRelativePathToRootTsConfig)(tree, options.appProjectRoot) }));
    if (options.unitTestRunner === 'none') {
        tree.delete((0, path_1.join)(options.appProjectRoot, './src/app/app.element.spec.ts'));
    }
}
function setupBundler(tree, options) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const main = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/main.ts');
        const tsConfig = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json');
        const assets = [
            (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/favicon.ico'),
            (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/assets'),
        ];
        if (options.bundler === 'webpack') {
            const { webpackProjectGenerator } = (0, devkit_1.ensurePackage)('@nx/webpack', versions_2.nxVersion);
            yield webpackProjectGenerator(tree, {
                project: options.projectName,
                main,
                tsConfig,
                compiler: (_a = options.compiler) !== null && _a !== void 0 ? _a : 'babel',
                devServer: true,
                isolatedConfig: true,
                webpackConfig: (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'webpack.config.js'),
                skipFormat: true,
            });
            const project = (0, devkit_1.readProjectConfiguration)(tree, options.projectName);
            const prodConfig = project.targets.build.configurations.production;
            const buildOptions = project.targets.build.options;
            buildOptions.assets = assets;
            buildOptions.index = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/index.html');
            buildOptions.baseHref = '/';
            buildOptions.styles = [
                (0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/styles.${options.style}`),
            ];
            // We can delete that, because this projest is an application
            // and applications have a .babelrc file in their root dir.
            // So Nx will find it and use it
            delete buildOptions.babelUpwardRootMode;
            buildOptions.scripts = [];
            prodConfig.fileReplacements = [
                {
                    replace: (0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/environments/environment.ts`),
                    with: (0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/environments/environment.prod.ts`),
                },
            ];
            prodConfig.optimization = true;
            prodConfig.outputHashing = 'all';
            prodConfig.sourceMap = false;
            prodConfig.namedChunks = false;
            prodConfig.extractLicenses = true;
            prodConfig.vendorChunk = false;
            (0, devkit_1.updateProjectConfiguration)(tree, options.projectName, project);
        }
        else if (options.bundler === 'none') {
            // TODO(jack): Flush this out... no bundler should be possible for web but the experience isn't holistic due to missing features (e.g. writing index.html).
            const project = (0, devkit_1.readProjectConfiguration)(tree, options.projectName);
            project.targets.build = {
                executor: `@nx/js:${options.compiler}`,
                outputs: ['{options.outputPath}'],
                options: {
                    main,
                    outputPath: (0, devkit_1.joinPathFragments)('dist', options.appProjectRoot),
                    tsConfig,
                    assets,
                },
            };
            (0, devkit_1.updateProjectConfiguration)(tree, options.projectName, project);
        }
        else {
            throw new Error('Unsupported bundler type');
        }
    });
}
function addProject(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const targets = {};
        (0, devkit_1.addProjectConfiguration)(tree, options.projectName, {
            projectType: 'application',
            root: options.appProjectRoot,
            sourceRoot: (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src'),
            tags: options.parsedTags,
            targets,
        }, options.standaloneConfig);
        if (options.bundler !== 'vite') {
            yield setupBundler(tree, options);
        }
    });
}
function setDefaults(tree, options) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    nxJson.generators = nxJson.generators || {};
    nxJson.generators['@nx/web:application'] = Object.assign({ style: options.style, linter: options.linter, unitTestRunner: options.unitTestRunner, e2eTestRunner: options.e2eTestRunner }, nxJson.generators['@nx/web:application']);
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
function applicationGenerator(host, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const options = normalizeOptions(host, schema);
        const tasks = [];
        const webTask = yield (0, init_1.webInitGenerator)(host, Object.assign(Object.assign({}, options), { skipFormat: true, 
            // Vite does not use babel by default
            skipBabelConfig: options.bundler === 'vite' }));
        tasks.push(webTask);
        createApplicationFiles(host, options);
        yield addProject(host, options);
        if (options.bundler === 'vite') {
            const { viteConfigurationGenerator } = (0, devkit_1.ensurePackage)('@nx/vite', versions_2.nxVersion);
            // We recommend users use `import.meta.env.MODE` and other variables in their code to differentiate between production and development.
            // See: https://vitejs.dev/guide/env-and-mode.html
            if (host.exists((0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/environments'))) {
                host.delete((0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/environments'));
            }
            const viteTask = yield viteConfigurationGenerator(host, {
                uiFramework: 'none',
                project: options.projectName,
                newProject: true,
                includeVitest: options.unitTestRunner === 'vitest',
                inSourceTests: options.inSourceTests,
                skipFormat: true,
            });
            tasks.push(viteTask);
        }
        if (options.bundler !== 'vite' && options.unitTestRunner === 'vitest') {
            const { vitestGenerator } = (0, devkit_1.ensurePackage)('@nx/vite', versions_2.nxVersion);
            const vitestTask = yield vitestGenerator(host, {
                uiFramework: 'none',
                project: options.projectName,
                coverageProvider: 'c8',
                inSourceTests: options.inSourceTests,
                skipFormat: true,
            });
            tasks.push(vitestTask);
        }
        if ((options.bundler === 'vite' || options.unitTestRunner === 'vitest') &&
            options.inSourceTests) {
            host.delete((0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/app/app.element.spec.ts`));
        }
        if (options.linter === 'eslint') {
            const { lintProjectGenerator } = yield (0, devkit_1.ensurePackage)('@nx/linter', versions_2.nxVersion);
            const lintTask = yield lintProjectGenerator(host, {
                linter: options.linter,
                project: options.projectName,
                tsConfigPaths: [
                    (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json'),
                ],
                unitTestRunner: options.unitTestRunner,
                eslintFilePatterns: [`${options.appProjectRoot}/**/*.ts`],
                skipFormat: true,
                setParserOptionsProject: options.setParserOptionsProject,
            });
            tasks.push(lintTask);
        }
        if (options.e2eTestRunner === 'cypress') {
            const { cypressProjectGenerator } = yield (0, devkit_1.ensurePackage)('@nx/cypress', versions_2.nxVersion);
            const cypressTask = yield cypressProjectGenerator(host, Object.assign(Object.assign({}, options), { name: `${options.name}-e2e`, directory: options.directory, project: options.projectName, skipFormat: true }));
            tasks.push(cypressTask);
        }
        if (options.unitTestRunner === 'jest') {
            const { jestProjectGenerator } = yield (0, devkit_1.ensurePackage)('@nx/jest', versions_2.nxVersion);
            const jestTask = yield jestProjectGenerator(host, {
                project: options.projectName,
                skipSerializers: true,
                setupFile: 'web-components',
                compiler: options.compiler,
                skipFormat: true,
            });
            tasks.push(jestTask);
        }
        if (options.compiler === 'swc') {
            const installTask = (0, devkit_1.addDependenciesToPackageJson)(host, {}, { '@swc/core': versions_1.swcCoreVersion, 'swc-loader': versions_2.swcLoaderVersion });
            tasks.push(installTask);
        }
        setDefaults(host, options);
        if (!schema.skipFormat) {
            yield (0, devkit_1.formatFiles)(host);
        }
        return (0, devkit_1.runTasksInSerial)(...tasks);
    });
}
exports.applicationGenerator = applicationGenerator;
function normalizeOptions(host, options) {
    var _a, _b, _c, _d;
    const { layoutDirectory, projectDirectory } = (0, devkit_1.extractLayoutDirectory)(options.directory);
    const appDirectory = projectDirectory
        ? `${(0, devkit_1.names)(projectDirectory).fileName}/${(0, devkit_1.names)(options.name).fileName}`
        : (0, devkit_1.names)(options.name).fileName;
    const { appsDir: defaultAppsDir, npmScope } = (0, devkit_1.getWorkspaceLayout)(host);
    const appsDir = layoutDirectory !== null && layoutDirectory !== void 0 ? layoutDirectory : defaultAppsDir;
    const appProjectName = appDirectory.replace(new RegExp('/', 'g'), '-');
    const e2eProjectName = `${appProjectName}-e2e`;
    const appProjectRoot = (0, devkit_1.joinPathFragments)(appsDir, appDirectory);
    const e2eProjectRoot = (0, devkit_1.joinPathFragments)(appsDir, `${appDirectory}-e2e`);
    const parsedTags = options.tags
        ? options.tags.split(',').map((s) => s.trim())
        : [];
    if (options.bundler === 'vite' && !options.unitTestRunner) {
        options.unitTestRunner = 'vitest';
    }
    options.style = options.style || 'css';
    options.linter = options.linter || 'eslint';
    options.unitTestRunner = options.unitTestRunner || 'jest';
    options.e2eTestRunner = options.e2eTestRunner || 'cypress';
    return Object.assign(Object.assign({}, options), { prefix: (_b = (_a = options.prefix) !== null && _a !== void 0 ? _a : npmScope) !== null && _b !== void 0 ? _b : 'app', name: (0, devkit_1.names)(options.name).fileName, compiler: (_c = options.compiler) !== null && _c !== void 0 ? _c : 'babel', bundler: (_d = options.bundler) !== null && _d !== void 0 ? _d : 'webpack', projectName: appProjectName, appProjectRoot,
        e2eProjectRoot,
        e2eProjectName,
        parsedTags });
}
exports.default = applicationGenerator;
exports.applicationSchematic = (0, devkit_1.convertNxGenerator)(applicationGenerator);
