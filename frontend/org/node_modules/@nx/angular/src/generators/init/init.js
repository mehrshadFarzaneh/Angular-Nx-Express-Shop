"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.angularInitGenerator = void 0;
const tslib_1 = require("tslib");
const cypress_1 = require("@nx/cypress");
const devkit_1 = require("@nx/devkit");
const jest_1 = require("@nx/jest");
const linter_1 = require("@nx/linter");
const js_1 = require("@nx/js");
const test_runners_1 = require("../../utils/test-runners");
const version_utils_1 = require("../utils/version-utils");
function angularInitGenerator(tree, rawOptions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const tasks = [];
        const options = normalizeOptions(rawOptions);
        const pkgVersions = (0, version_utils_1.versions)(tree);
        const peerDepsToInstall = ['@angular-devkit/core'];
        let devkitVersion;
        peerDepsToInstall.forEach((pkg) => {
            var _a;
            const packageVersion = (0, version_utils_1.getInstalledPackageVersion)(tree, pkg);
            if (!packageVersion) {
                devkitVersion !== null && devkitVersion !== void 0 ? devkitVersion : (devkitVersion = (_a = (0, version_utils_1.getInstalledPackageVersion)(tree, '@angular-devkit/build-angular')) !== null && _a !== void 0 ? _a : pkgVersions.angularDevkitVersion);
                try {
                    (0, devkit_1.ensurePackage)(pkg, devkitVersion);
                }
                catch (_b) {
                    // @schematics/angular cannot be required so this fails but this will still allow wrapping the schematic later on
                }
                if (!options.skipPackageJson) {
                    tasks.push((0, devkit_1.addDependenciesToPackageJson)(tree, {}, { [pkg]: devkitVersion }));
                }
            }
        });
        setDefaults(tree, options);
        const jsTask = yield (0, js_1.initGenerator)(tree, Object.assign(Object.assign({}, options), { tsConfigName: options.rootProject ? 'tsconfig.json' : 'tsconfig.base.json', js: false, skipFormat: true }));
        tasks.push(jsTask);
        if (!options.skipPackageJson) {
            tasks.push(updateDependencies(tree, pkgVersions));
        }
        const unitTestTask = yield addUnitTestRunner(tree, options, pkgVersions.jestPresetAngularVersion);
        tasks.push(unitTestTask);
        const e2eTask = yield addE2ETestRunner(tree, options);
        tasks.push(e2eTask);
        ignoreAngularCacheDirectory(tree);
        if (!options.skipFormat) {
            yield (0, devkit_1.formatFiles)(tree);
        }
        return (0, devkit_1.runTasksInSerial)(...tasks);
    });
}
exports.angularInitGenerator = angularInitGenerator;
function normalizeOptions(options) {
    var _a, _b, _c, _d, _e, _f, _g;
    return {
        e2eTestRunner: (_a = options.e2eTestRunner) !== null && _a !== void 0 ? _a : test_runners_1.E2eTestRunner.Cypress,
        linter: (_b = options.linter) !== null && _b !== void 0 ? _b : linter_1.Linter.EsLint,
        skipFormat: (_c = options.skipFormat) !== null && _c !== void 0 ? _c : false,
        skipInstall: (_d = options.skipInstall) !== null && _d !== void 0 ? _d : false,
        skipPackageJson: (_e = options.skipPackageJson) !== null && _e !== void 0 ? _e : false,
        style: (_f = options.style) !== null && _f !== void 0 ? _f : 'css',
        unitTestRunner: (_g = options.unitTestRunner) !== null && _g !== void 0 ? _g : test_runners_1.UnitTestRunner.Jest,
        rootProject: options.rootProject,
    };
}
function setDefaults(host, options) {
    const nxJson = (0, devkit_1.readNxJson)(host);
    nxJson.generators = nxJson.generators || {};
    nxJson.generators['@nx/angular:application'] = Object.assign({ style: options.style, linter: options.linter, unitTestRunner: options.unitTestRunner, e2eTestRunner: options.e2eTestRunner }, (nxJson.generators['@nx/angular:application'] || {}));
    nxJson.generators['@nx/angular:library'] = Object.assign({ linter: options.linter, unitTestRunner: options.unitTestRunner }, (nxJson.generators['@nx/angular:library'] || {}));
    nxJson.generators['@nx/angular:component'] = Object.assign({ style: options.style }, (nxJson.generators['@nx/angular:component'] || {}));
    (0, devkit_1.updateNxJson)(host, nxJson);
}
function updateDependencies(tree, versions) {
    var _a, _b, _c, _d, _e;
    const angularVersion = (_a = (0, version_utils_1.getInstalledPackageVersion)(tree, '@angular/core')) !== null && _a !== void 0 ? _a : versions.angularVersion;
    const angularDevkitVersion = (_b = (0, version_utils_1.getInstalledPackageVersion)(tree, '@angular-devkit/build-angular')) !== null && _b !== void 0 ? _b : versions.angularDevkitVersion;
    const rxjsVersion = (_c = (0, version_utils_1.getInstalledPackageVersion)(tree, 'rxjs')) !== null && _c !== void 0 ? _c : versions.rxjsVersion;
    const tsLibVersion = (_d = (0, version_utils_1.getInstalledPackageVersion)(tree, 'tslib')) !== null && _d !== void 0 ? _d : versions.tsLibVersion;
    const zoneJsVersion = (_e = (0, version_utils_1.getInstalledPackageVersion)(tree, 'zone.js')) !== null && _e !== void 0 ? _e : versions.zoneJsVersion;
    return (0, version_utils_1.addDependenciesToPackageJsonIfDontExist)(tree, {
        '@angular/animations': angularVersion,
        '@angular/common': angularVersion,
        '@angular/compiler': angularVersion,
        '@angular/core': angularVersion,
        '@angular/forms': angularVersion,
        '@angular/platform-browser': angularVersion,
        '@angular/platform-browser-dynamic': angularVersion,
        '@angular/router': angularVersion,
        rxjs: rxjsVersion,
        tslib: tsLibVersion,
        'zone.js': zoneJsVersion,
    }, {
        '@angular/cli': angularDevkitVersion,
        '@angular/compiler-cli': angularVersion,
        '@angular/language-service': angularVersion,
        '@angular-devkit/build-angular': angularDevkitVersion,
        '@angular-devkit/schematics': angularDevkitVersion,
        '@schematics/angular': angularDevkitVersion,
    });
}
function addUnitTestRunner(tree, options, jestPresetAngularVersion) {
    var _a;
    var _b;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        switch (options.unitTestRunner) {
            case test_runners_1.UnitTestRunner.Jest:
                if (!options.skipPackageJson) {
                    (_a = (_b = process.env).npm_config_legacy_peer_deps) !== null && _a !== void 0 ? _a : (_b.npm_config_legacy_peer_deps = 'true');
                    (0, version_utils_1.addDependenciesToPackageJsonIfDontExist)(tree, {}, {
                        'jest-preset-angular': jestPresetAngularVersion,
                    });
                }
                return (0, jest_1.jestInitGenerator)(tree, {
                    skipPackageJson: options.skipPackageJson,
                });
            default:
                return () => { };
        }
    });
}
function addE2ETestRunner(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        switch (options.e2eTestRunner) {
            case test_runners_1.E2eTestRunner.Cypress:
                return (0, cypress_1.cypressInitGenerator)(tree, {
                    skipPackageJson: options.skipPackageJson,
                });
            default:
                return () => { };
        }
    });
}
function ignoreAngularCacheDirectory(tree) {
    var _a, _b;
    const { cli } = (0, devkit_1.readNxJson)(tree);
    // angular-specific cli config is supported though is not included in the
    // NxJsonConfiguration type
    const angularCacheDir = (_b = (_a = cli === null || cli === void 0 ? void 0 : cli.cache) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '.angular';
    addGitIgnoreEntry(tree, angularCacheDir);
    addPrettierIgnoreEntry(tree, angularCacheDir);
}
function addGitIgnoreEntry(tree, entry) {
    if (tree.exists('.gitignore')) {
        let content = tree.read('.gitignore', 'utf-8');
        if (/^\.angular$/gm.test(content)) {
            return;
        }
        content = `${content}\n${entry}\n`;
        tree.write('.gitignore', content);
    }
    else {
        devkit_1.logger.warn(`Couldn't find .gitignore file to update`);
    }
}
function addPrettierIgnoreEntry(tree, entry) {
    if (!tree.exists('.prettierignore')) {
        return;
    }
    let content = tree.read('.prettierignore', 'utf-8');
    if (/^\.angular$/gm.test(content)) {
        return;
    }
    content = `${content}\n${entry}\n`;
    tree.write('.prettierignore', content);
}
exports.default = angularInitGenerator;
