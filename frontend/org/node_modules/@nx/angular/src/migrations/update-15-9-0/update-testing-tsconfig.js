"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTestingTsconfigForJest = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const executor_options_utils_1 = require("@nx/devkit/src/generators/executor-options-utils");
function updateTestingTsconfigForJest(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const graph = yield (0, devkit_1.createProjectGraphAsync)();
        const projects = (0, devkit_1.getProjects)(tree);
        (0, executor_options_utils_1.forEachExecutorOptionsInGraph)(graph, '@nrwl/jest:jest', (options, projectName) => {
            const projectConfig = projects.get(projectName);
            if (!isJestPresetAngular(tree, options.jestConfig)) {
                return;
            }
            const tsconfigPath = (0, devkit_1.joinPathFragments)(projectConfig.root, 'tsconfig.spec.json');
            if (tree.exists(tsconfigPath)) {
                (0, devkit_1.updateJson)(tree, tsconfigPath, (json) => {
                    var _a, _b;
                    var _c;
                    (_a = json.compilerOptions) !== null && _a !== void 0 ? _a : (json.compilerOptions = {});
                    (_b = (_c = json.compilerOptions).target) !== null && _b !== void 0 ? _b : (_c.target = 'es2016');
                    return json;
                }, { expectComments: true, allowTrailingComma: true });
            }
        });
        yield (0, devkit_1.formatFiles)(tree);
    });
}
exports.updateTestingTsconfigForJest = updateTestingTsconfigForJest;
function isJestPresetAngular(tree, jestConfigPath) {
    if (jestConfigPath && tree.exists(jestConfigPath)) {
        const contents = tree.read(jestConfigPath, 'utf-8');
        return contents.includes('jest-preset-angular');
    }
    return false;
}
exports.default = updateTestingTsconfigForJest;
