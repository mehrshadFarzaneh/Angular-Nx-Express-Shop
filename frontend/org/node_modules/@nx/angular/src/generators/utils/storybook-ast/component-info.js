"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStandaloneComponentsInfo = exports.getComponentsInfo = void 0;
const devkit_1 = require("@nx/devkit");
const ensure_typescript_1 = require("@nx/js/src/utils/typescript/ensure-typescript");
const path_1 = require("path");
const ast_utils_1 = require("../../../utils/nx-devkit/ast-utils");
const module_info_1 = require("./module-info");
const tree_utilities_1 = require("./tree-utilities");
let tsModule;
let tsquery;
function getComponentsInfo(tree, entryPoint, moduleFilePaths, projectName) {
    return moduleFilePaths.flatMap((moduleFilePath) => {
        const file = (0, ast_utils_1.getTsSourceFile)(tree, moduleFilePath);
        const declaredComponents = (0, module_info_1.getModuleDeclaredComponents)(file, moduleFilePath, projectName);
        if (declaredComponents.length === 0) {
            return undefined;
        }
        if (!tsModule) {
            tsModule = (0, ensure_typescript_1.ensureTypescript)();
        }
        const imports = file.statements.filter((statement) => statement.kind === tsModule.SyntaxKind.ImportDeclaration);
        const componentsInfo = declaredComponents.map((componentName) => getComponentInfo(tree, entryPoint, file, imports, moduleFilePath, componentName));
        return componentsInfo;
    });
}
exports.getComponentsInfo = getComponentsInfo;
function getStandaloneComponentsInfo(tree, entryPoint) {
    const componentsInfo = [];
    (0, devkit_1.visitNotIgnoredFiles)(tree, entryPoint.path, (filePath) => {
        var _a;
        const normalizedFilePath = (0, devkit_1.normalizePath)(filePath);
        if ((_a = entryPoint.excludeDirs) === null || _a === void 0 ? void 0 : _a.some((excludeDir) => normalizedFilePath.startsWith(excludeDir))) {
            return;
        }
        if ((0, path_1.extname)(normalizedFilePath) !== '.ts' ||
            normalizedFilePath.includes('.storybook')) {
            return;
        }
        const standaloneComponents = getStandaloneComponents(tree, normalizedFilePath);
        if (!standaloneComponents.length) {
            return;
        }
        standaloneComponents.forEach((componentName) => {
            componentsInfo.push({
                componentFileName: (0, path_1.basename)(normalizedFilePath, '.ts'),
                moduleFolderPath: entryPoint.path,
                name: componentName,
                path: (0, path_1.dirname)((0, path_1.relative)(entryPoint.path, normalizedFilePath)),
                entryPointName: entryPoint.name,
            });
        });
    });
    return componentsInfo;
}
exports.getStandaloneComponentsInfo = getStandaloneComponentsInfo;
function getStandaloneComponents(tree, filePath) {
    if (!tsquery) {
        (0, ensure_typescript_1.ensureTypescript)();
        tsquery = require('@phenomnomnominal/tsquery').tsquery;
    }
    const fileContent = tree.read(filePath, 'utf-8');
    const ast = tsquery.ast(fileContent);
    const components = tsquery(ast, 'ClassDeclaration:has(Decorator > CallExpression:has(Identifier[name=Component]) ObjectLiteralExpression PropertyAssignment Identifier[name=standalone] ~ TrueKeyword) > Identifier', { visitAllChildren: true });
    return components.map((component) => component.getText());
}
function getComponentImportPath(componentName, imports) {
    if (!tsModule) {
        tsModule = (0, ensure_typescript_1.ensureTypescript)();
    }
    const componentImportStatement = imports.find((statement) => {
        const namedImports = statement
            .getChildren()
            .find((node) => node.kind === tsModule.SyntaxKind.ImportClause)
            .getChildren()
            .find((node) => node.kind === tsModule.SyntaxKind.NamedImports);
        if (namedImports === undefined)
            return false;
        const importedIdentifiers = namedImports
            .getChildren()
            .find((node) => node.kind === tsModule.SyntaxKind.SyntaxList)
            .getChildren()
            .filter((node) => node.kind === tsModule.SyntaxKind.ImportSpecifier)
            .map((node) => node.getText());
        return importedIdentifiers.includes(componentName);
    });
    const importPath = componentImportStatement
        .getChildren()
        .find((node) => node.kind === tsModule.SyntaxKind.StringLiteral)
        .getText()
        .slice(1, -1);
    return importPath;
}
function getComponentInfo(tree, entryPoint, sourceFile, imports, moduleFilePath, componentName) {
    try {
        if (!tsquery) {
            (0, ensure_typescript_1.ensureTypescript)();
            tsquery = require('@phenomnomnominal/tsquery').tsquery;
        }
        const moduleFolderPath = (0, path_1.dirname)(moduleFilePath);
        // try to get the component from the same file (inline scam)
        const node = tsquery(sourceFile, `ClassDeclaration:has(Decorator > CallExpression > Identifier[name=Component]):has(Identifier[name=${componentName}])`, { visitAllChildren: true })[0];
        if (node) {
            return {
                componentFileName: (0, path_1.basename)(moduleFilePath, '.ts'),
                moduleFolderPath,
                name: componentName,
                path: '.',
                entryPointName: entryPoint.name,
            };
        }
        // try to get the component from the imports
        const componentFilePathRelativeToModule = getComponentImportPath(componentName, imports);
        const componentImportPath = getFullComponentFilePath(moduleFolderPath, componentFilePathRelativeToModule);
        if (tree.exists(componentImportPath) && !tree.isFile(componentImportPath)) {
            return getComponentInfoFromDir(tree, entryPoint, componentImportPath, componentName, moduleFolderPath);
        }
        const path = (0, path_1.dirname)(componentFilePathRelativeToModule);
        const componentFileName = (0, path_1.basename)(componentFilePathRelativeToModule);
        return {
            componentFileName,
            moduleFolderPath,
            name: componentName,
            path,
            entryPointName: entryPoint.name,
        };
    }
    catch (ex) {
        devkit_1.logger.warn(`Could not generate a story for ${componentName}. Error: ${ex}`);
        return undefined;
    }
}
function getComponentInfoFromDir(tree, entryPoint, dir, componentName, moduleFolderPath) {
    let path = null;
    let componentFileName = null;
    const componentImportPathChildren = (0, tree_utilities_1.getAllFilesRecursivelyFromDir)(tree, dir);
    for (const candidateFile of componentImportPathChildren) {
        if (candidateFile.endsWith('.ts')) {
            const content = tree.read(candidateFile, 'utf-8');
            const classAndComponentRegex = new RegExp(`@Component[\\s\\S\n]*?\\bclass ${componentName}\\b`, 'g');
            if (content.match(classAndComponentRegex)) {
                path = candidateFile
                    .slice(0, candidateFile.lastIndexOf('/'))
                    .replace(moduleFolderPath, '.');
                componentFileName = candidateFile.slice(candidateFile.lastIndexOf('/') + 1, candidateFile.lastIndexOf('.'));
                break;
            }
        }
    }
    if (path === null) {
        throw new Error(`Path to component ${componentName} couldn't be found. Please open an issue on https://github.com/nrwl/nx/issues.`);
    }
    return {
        componentFileName,
        moduleFolderPath,
        name: componentName,
        path,
        entryPointName: entryPoint.name,
    };
}
function getFullComponentFilePath(moduleFolderPath, componentFilePath) {
    if (moduleFolderPath.startsWith('/')) {
        moduleFolderPath = moduleFolderPath.slice(1, moduleFolderPath.length);
    }
    return (0, devkit_1.joinPathFragments)(moduleFolderPath, componentFilePath);
}
