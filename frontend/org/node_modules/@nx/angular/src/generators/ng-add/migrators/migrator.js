"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Migrator = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
class Migrator {
    constructor(tree, projectConfig, logger) {
        this.tree = tree;
        this.projectConfig = projectConfig;
        this.logger = logger;
        this.originalProjectConfig = Object.freeze(JSON.parse(JSON.stringify(this.projectConfig)));
    }
    convertAsset(asset) {
        if (typeof asset === 'string') {
            return this.convertSourceRootPath(asset);
        }
        else {
            return Object.assign(Object.assign({}, asset), { input: this.convertSourceRootPath(asset.input) });
        }
    }
    convertRootPath(originalPath) {
        return (originalPath === null || originalPath === void 0 ? void 0 : originalPath.startsWith(this.project.oldRoot))
            ? (0, devkit_1.joinPathFragments)(this.project.newRoot, originalPath.replace(this.project.oldRoot, ''))
            : originalPath;
    }
    moveFile(from, to, required = true) {
        if (!this.tree.exists(from)) {
            if (required) {
                this.logger.warn(`The path "${from}" does not exist. Skipping.`);
            }
        }
        else if (this.tree.exists(to)) {
            if (required) {
                this.logger.warn(`The path "${to}" already exists. Skipping.`);
            }
        }
        else {
            const contents = this.tree.read(from);
            this.tree.write(to, contents);
            this.tree.delete(from);
        }
    }
    moveFilePathsFromTargetToProjectRoot(target, options) {
        options.forEach((option) => {
            this.getTargetValuesForOption(target, option).forEach((path) => {
                this.moveProjectRootFile(path);
            });
        });
    }
    moveProjectRootFile(filePath, isRequired = true) {
        if (!filePath) {
            return;
        }
        const filename = !!filePath ? (0, path_1.basename)(filePath) : '';
        const from = filePath;
        const to = (0, devkit_1.joinPathFragments)(this.project.newRoot, filename);
        this.moveFile(from, to, isRequired);
    }
    // TODO(leo): This should be moved to BuilderMigrator once everything is split into builder migrators.
    updateCacheableOperations(targetNames) {
        var _a;
        if (!targetNames.length) {
            return;
        }
        const nxJson = (0, devkit_1.readNxJson)(this.tree);
        Object.keys((_a = nxJson.tasksRunnerOptions) !== null && _a !== void 0 ? _a : {}).forEach((taskRunnerName) => {
            var _a;
            const taskRunner = nxJson.tasksRunnerOptions[taskRunnerName];
            taskRunner.options.cacheableOperations = Array.from(new Set([
                ...((_a = taskRunner.options.cacheableOperations) !== null && _a !== void 0 ? _a : []),
                ...targetNames,
            ]));
        });
        (0, devkit_1.updateNxJson)(this.tree, nxJson);
    }
    // TODO(leo): This should be moved to BuilderMigrator once everything is split into builder migrators.
    updateTsConfigFile(tsConfigPath, rootTsConfigFile, projectOffsetFromRoot) {
        (0, devkit_1.updateJson)(this.tree, tsConfigPath, (json) => {
            var _a;
            json.extends = `${projectOffsetFromRoot}${rootTsConfigFile}`;
            json.compilerOptions = (_a = json.compilerOptions) !== null && _a !== void 0 ? _a : {};
            json.compilerOptions.outDir = `${projectOffsetFromRoot}dist/out-tsc`;
            return json;
        });
    }
    convertSourceRootPath(originalPath) {
        return (originalPath === null || originalPath === void 0 ? void 0 : originalPath.startsWith(this.project.oldSourceRoot))
            ? (0, devkit_1.joinPathFragments)(this.project.newSourceRoot, originalPath.replace(this.project.oldSourceRoot, ''))
            : originalPath;
    }
    getTargetValuesForOption(target, optionPath) {
        var _a;
        const values = new Set();
        const value = this.getValueForOption(target.options, optionPath);
        if (value) {
            values.add(value);
        }
        for (const configuration of Object.values((_a = target.configurations) !== null && _a !== void 0 ? _a : {})) {
            const value = this.getValueForOption(configuration, optionPath);
            if (value) {
                values.add(value);
            }
        }
        return Array.from(values);
    }
    getValueForOption(options, optionPath) {
        if (!options) {
            return null;
        }
        const segments = optionPath.split('.');
        let value = options;
        for (const segment of segments) {
            if (value && value[segment]) {
                value = value[segment];
            }
            else {
                return null;
            }
        }
        return value;
    }
}
exports.Migrator = Migrator;
