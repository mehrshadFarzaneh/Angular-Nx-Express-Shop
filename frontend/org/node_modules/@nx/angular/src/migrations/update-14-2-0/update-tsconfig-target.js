"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const devkit_2 = require("@nx/devkit");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const path_1 = require("path");
const jestExecutor = '@nrwl/jest:jest';
const executors = [
    '@angular-devkit/build-angular:browser',
    '@angular-devkit/build-angular:karma',
    '@angular-devkit/build-angular:ng-packagr',
    '@nrwl/angular:webpack-browser',
    '@nrwl/angular:delegate-build',
    '@nrwl/angular:ng-packagr-lite',
    '@nrwl/angular:package',
];
const skipTargets = ['es2020', 'es2021', 'es2022', 'esnext'];
function default_1(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const tsConfigPaths = yield collectTsConfigPaths(tree);
        for (const tsConfigPath of tsConfigPaths) {
            (0, devkit_2.updateJson)(tree, tsConfigPath, (json) => {
                var _a, _b, _c;
                if (!((_a = json.compilerOptions) === null || _a === void 0 ? void 0 : _a.target) ||
                    (((_b = json.compilerOptions) === null || _b === void 0 ? void 0 : _b.target) &&
                        !skipTargets.includes(json.compilerOptions.target.toLowerCase()))) {
                    (_c = json.compilerOptions) !== null && _c !== void 0 ? _c : (json.compilerOptions = {});
                    json.compilerOptions.target = 'es2020';
                }
                return json;
            }, {
                allowTrailingComma: true,
                disallowComments: false,
            });
        }
        yield (0, devkit_2.formatFiles)(tree);
    });
}
exports.default = default_1;
function collectTsConfigPaths(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const uniqueTsConfigs = new Set([]);
        const projectGraph = yield (0, devkit_2.createProjectGraphAsync)();
        const angularProjects = Object.entries(projectGraph.dependencies)
            .filter(([node, dep]) => dep.some(({ target }) => { var _a; return target === 'npm:@angular/core' && !((_a = projectGraph.externalNodes) === null || _a === void 0 ? void 0 : _a[node]); }))
            .map(([projectName]) => ({
            projectName,
            project: (0, devkit_2.readProjectConfiguration)(tree, projectName),
        }));
        for (const { projectName, project } of angularProjects) {
            const tsConfigPath = (0, devkit_2.joinPathFragments)(project.root, 'tsconfig.json');
            if (tree.exists(tsConfigPath)) {
                uniqueTsConfigs.add(tsConfigPath);
                const targetTsConfigPaths = getProjectTsConfigPaths(tree, project, projectName, false);
                targetTsConfigPaths.forEach((tsConfigPath) => {
                    var _a;
                    const tsConfig = (0, devkit_1.readJson)(tree, tsConfigPath, {
                        allowTrailingComma: true,
                        disallowComments: false,
                    });
                    if ((_a = tsConfig.compilerOptions) === null || _a === void 0 ? void 0 : _a.target) {
                        uniqueTsConfigs.add(tsConfigPath);
                    }
                });
                continue;
            }
            const tsConfigPaths = getProjectTsConfigPaths(tree, project, projectName);
            for (const tsConfigPath of tsConfigPaths) {
                uniqueTsConfigs.add(tsConfigPath);
            }
        }
        return Array.from(uniqueTsConfigs);
    });
}
function getProjectTsConfigPaths(tree, project, projectName, shouldWarn = true) {
    const tsConfigPaths = new Set();
    for (const [targetName, target] of Object.entries(project.targets || {})) {
        if (executors.includes(target.executor)) {
            const tsConfigPathsFromTarget = getPathValuesFromTarget(target, 'tsConfig');
            tsConfigPathsFromTarget.forEach((tsConfigPath) => {
                if (tree.exists(tsConfigPath)) {
                    tsConfigPaths.add(tsConfigPath);
                }
                else if (shouldWarn) {
                    devkit_2.logger.warn(`The "${tsConfigPath}" file specified in the "${targetName}" target of the "${projectName}" project could not be found. ` +
                        'Skipping setting the target to ES2020.');
                }
            });
        }
        else if (target.executor === jestExecutor) {
            const tsConfigPathsFromJestTarget = getTsConfigPathsFromJestTarget(tree, target, targetName, projectName, shouldWarn);
            tsConfigPathsFromJestTarget.forEach((tsConfigPath) => {
                tsConfigPaths.add(tsConfigPath);
            });
        }
        else if (shouldWarn) {
            devkit_2.logger.warn(`The "${targetName}" target of the "${projectName}" project is using an executor not supported by the migration. ` +
                'Skipping setting the TS target to ES2020 for the project.');
        }
    }
    return Array.from(tsConfigPaths);
}
function getTsConfigPathsFromJestTarget(tree, target, targetName, projectName, shouldWarn) {
    const tsConfigPaths = [];
    const jestConfigPaths = getPathValuesFromTarget(target, 'jestConfig');
    if (!jestConfigPaths.length && shouldWarn) {
        devkit_2.logger.warn(`The "${targetName}" target of the "${projectName}" project is using the "${jestExecutor}" executor but no "jestConfig" property was specified. ` +
            'Skipping setting the TS compilation target to ES2020 for the project.');
    }
    for (const jestConfigPath of jestConfigPaths) {
        const tsConfigPath = getTsConfigFromJestConfig(tree, jestConfigPath, targetName, projectName, shouldWarn);
        if (tsConfigPath) {
            tsConfigPaths.push(tsConfigPath);
        }
    }
    return tsConfigPaths;
}
function getTsConfigFromJestConfig(tree, jestConfigPath, targetName, projectName, shouldWarn) {
    if (!tree.exists(jestConfigPath)) {
        if (shouldWarn) {
            devkit_2.logger.warn(`The "${jestConfigPath}" file specified in the "${targetName}" target of the "${projectName}" project could not be found. ` +
                `The TS config file used by the target can't be determined. Skipping setting the target to ES2020.`);
        }
        return undefined;
    }
    const jestConfig = tree.read(jestConfigPath, 'utf-8');
    const jestConfigAst = tsquery_1.tsquery.ast(jestConfig);
    const tsJestTsConfigStringLiteral = (0, tsquery_1.tsquery)(jestConfigAst, 'PropertyAssignment:has(Identifier[name=globals]) PropertyAssignment:has(StringLiteral[value=ts-jest]) PropertyAssignment Identifier[name=tsconfig] ~ StringLiteral', { visitAllChildren: true })[0];
    if (!tsJestTsConfigStringLiteral) {
        if (shouldWarn) {
            devkit_2.logger.warn(`Couldn't find the "tsconfig" property for "ts-jest" in the Jest configuration file "${jestConfigPath}" specified in the ` +
                `"${targetName}" target of the "${projectName}" project. The TS config file used by the target can't be determined. ` +
                'Skipping setting the target to ES2020.');
        }
        return undefined;
    }
    const tsJestTsConfigValue = tsJestTsConfigStringLiteral
        .getText()
        .replace(/['"]/g, '');
    const tsConfigPath = tsJestTsConfigValue.replace('<rootDir>', (0, path_1.dirname)(jestConfigPath));
    if (!tree.exists(tsConfigPath)) {
        if (shouldWarn) {
            devkit_2.logger.warn(`The "${tsJestTsConfigValue}" file specified in the Jest configuration file "${jestConfigPath}" of the "${targetName}" target ` +
                `of the "${projectName}" project could not be found. Skipping setting the target to ES2020.`);
        }
        return undefined;
    }
    return tsConfigPath;
}
function getPathValuesFromTarget(target, option) {
    var _a, _b;
    const values = [];
    if ((_a = target.options) === null || _a === void 0 ? void 0 : _a[option]) {
        values.push(target.options[option]);
    }
    Object.values((_b = target.configurations) !== null && _b !== void 0 ? _b : {}).forEach((options) => {
        if (options[option]) {
            values.push(options[option]);
        }
    });
    return values;
}
