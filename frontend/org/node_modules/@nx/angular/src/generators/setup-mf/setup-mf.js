"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupMf = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const lib_1 = require("./lib");
const version_utils_1 = require("../utils/version-utils");
const versions_1 = require("../../utils/versions");
const semver_1 = require("semver");
function setupMf(tree, rawOptions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const installedAngularInfo = (0, version_utils_1.getInstalledAngularVersionInfo)(tree);
        if ((0, semver_1.lt)(installedAngularInfo.version, '14.1.0') && rawOptions.standalone) {
            throw new Error(`The --standalone flag is not supported in your current version of Angular (${installedAngularInfo.version}). Please update to a version of Angular that supports Standalone Components (>= 14.1.0).`);
        }
        const options = (0, lib_1.normalizeOptions)(tree, rawOptions);
        const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.appName);
        let installTask = () => { };
        if (options.mfType === 'remote') {
            (0, lib_1.addRemoteToHost)(tree, options);
            (0, lib_1.addRemoteEntry)(tree, options, projectConfig.root);
            (0, lib_1.removeDeadCodeFromRemote)(tree, options);
            installTask = (0, devkit_1.addDependenciesToPackageJson)(tree, {}, { '@nx/web': versions_1.nxVersion });
        }
        const remotesWithPorts = (0, lib_1.getRemotesWithPorts)(tree, options);
        (0, lib_1.generateWebpackConfig)(tree, options, projectConfig.root, remotesWithPorts);
        (0, lib_1.changeBuildTarget)(tree, options);
        (0, lib_1.updateTsConfigTarget)(tree, options);
        (0, lib_1.setupServeTarget)(tree, options);
        (0, lib_1.fixBootstrap)(tree, projectConfig.root, options);
        if (options.mfType === 'host') {
            (0, lib_1.setupHostIfDynamic)(tree, options);
            (0, lib_1.updateHostAppRoutes)(tree, options);
        }
        if (!options.skipE2E) {
            (0, lib_1.addCypressOnErrorWorkaround)(tree, options);
        }
        // format files
        if (!options.skipFormat) {
            yield (0, devkit_1.formatFiles)(tree);
        }
        return installTask;
    });
}
exports.setupMf = setupMf;
exports.default = setupMf;
