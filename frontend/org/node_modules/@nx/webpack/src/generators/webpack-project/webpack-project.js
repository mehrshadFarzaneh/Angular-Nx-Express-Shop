"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webpackProjectSchematic = exports.webpackProjectGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const init_1 = require("../init/init");
function webpackProjectGenerator(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const task = yield (0, init_1.webpackInitGenerator)(tree, Object.assign(Object.assign({}, options), { skipFormat: true }));
        checkForTargetConflicts(tree, options);
        addBuildTarget(tree, options);
        if (options.devServer) {
            addServeTarget(tree, options);
        }
        if (!options.skipFormat) {
            yield (0, devkit_1.formatFiles)(tree);
        }
        return task;
    });
}
exports.webpackProjectGenerator = webpackProjectGenerator;
function checkForTargetConflicts(tree, options) {
    var _a, _b;
    if (options.skipValidation)
        return;
    const project = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    if ((_a = project.targets) === null || _a === void 0 ? void 0 : _a.build) {
        throw new Error(`Project "${project.name}" already has a build target. Pass --skipValidation to ignore this error.`);
    }
    if (options.devServer && ((_b = project.targets) === null || _b === void 0 ? void 0 : _b.serve)) {
        throw new Error(`Project "${project.name}" already has a serve target. Pass --skipValidation to ignore this error.`);
    }
}
function addBuildTarget(tree, options) {
    var _a, _b, _c;
    const project = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    const buildOptions = {
        target: options.target,
        outputPath: (0, devkit_1.joinPathFragments)('dist', project.root),
        compiler: (_a = options.compiler) !== null && _a !== void 0 ? _a : 'babel',
        main: (_b = options.main) !== null && _b !== void 0 ? _b : (0, devkit_1.joinPathFragments)(project.root, 'src/main.ts'),
        tsConfig: (_c = options.tsConfig) !== null && _c !== void 0 ? _c : (0, devkit_1.joinPathFragments)(project.root, 'tsconfig.app.json'),
        webpackConfig: (0, devkit_1.joinPathFragments)(project.root, 'webpack.config.js'),
    };
    if (options.webpackConfig) {
        buildOptions.webpackConfig = options.webpackConfig;
    }
    if (options.babelConfig) {
        buildOptions.babelConfig = options.babelConfig;
    }
    else {
        buildOptions.babelUpwardRootMode = true;
    }
    if (options.target === 'web') {
        tree.write((0, devkit_1.joinPathFragments)(project.root, 'webpack.config.js'), `
const { composePlugins, withNx, withWeb } = require('@nx/webpack');

// Nx plugins for webpack.
module.exports = composePlugins(withNx(), withWeb(), (config) => {
  // Update the webpack config as needed here.
  // e.g. \`config.plugins.push(new MyPlugin())\`
  return config;
});
`);
    }
    else {
        tree.write((0, devkit_1.joinPathFragments)(project.root, 'webpack.config.js'), `
const { composePlugins, withNx } = require('@nx/webpack');

// Nx plugins for webpack.
module.exports = composePlugins(withNx(), (config) => {
  // Update the webpack config as needed here.
  // e.g. \`config.plugins.push(new MyPlugin())\`
  return config;
});
`);
    }
    (0, devkit_1.updateProjectConfiguration)(tree, options.project, Object.assign(Object.assign({}, project), { targets: Object.assign(Object.assign({}, project.targets), { build: {
                executor: '@nx/webpack:webpack',
                outputs: ['{options.outputPath}'],
                defaultConfiguration: 'production',
                options: buildOptions,
                configurations: {
                    production: {
                        optimization: true,
                        outputHashing: options.target === 'web' ? 'all' : 'none',
                        sourceMap: false,
                        namedChunks: false,
                        extractLicenses: true,
                        vendorChunk: false,
                    },
                },
            } }) }));
}
function addServeTarget(tree, options) {
    const project = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    (0, devkit_1.updateProjectConfiguration)(tree, options.project, Object.assign(Object.assign({}, project), { targets: Object.assign(Object.assign({}, project.targets), { serve: {
                executor: '@nx/webpack:dev-server',
                options: {
                    buildTarget: `${options.project}:build`,
                },
                configurations: {
                    production: {
                        buildTarget: `${options.project}:build:production`,
                    },
                },
            } }) }));
}
exports.default = webpackProjectGenerator;
exports.webpackProjectSchematic = (0, devkit_1.convertNxGenerator)(webpackProjectGenerator);
