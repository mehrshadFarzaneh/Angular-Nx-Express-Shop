"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scamToStandalone = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const lib_1 = require("./lib");
const version_utils_1 = require("../utils/version-utils");
const semver_1 = require("semver");
function scamToStandalone(tree, { component, project: projectName, skipFormat }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const installedAngularVersionInfo = (0, version_utils_1.getInstalledAngularVersionInfo)(tree);
        if ((0, semver_1.lt)(installedAngularVersionInfo.version, '14.1.0')) {
            throw new Error((0, devkit_1.stripIndents) `This generator is only supported with Angular >= 14.1.0. You are currently using ${installedAngularVersionInfo.version}.
    You can resolve this error by migrating to Angular 14.1.0.`);
        }
        const projects = (0, devkit_1.getProjects)(tree);
        let project = (0, lib_1.getTargetProject)(projectName, projects);
        const normalizedComponentPath = (0, devkit_1.joinPathFragments)(project.root, component);
        if (!tree.exists(normalizedComponentPath)) {
            throw new Error(`The path provided to the component (${normalizedComponentPath}) does not exist. Please ensure the correct path has been provided.`);
        }
        const { componentFileContents, componentAST, componentName } = (0, lib_1.getComponentDataFromAST)(tree, normalizedComponentPath);
        const isInlineScam = (0, lib_1.verifyIsInlineScam)(componentAST);
        if (!isInlineScam) {
            throw new Error('This generator currently only supports inline SCAMs. We could not find an accompanying NgModule within the component file, please ensure the SCAM provided is an inline scam.');
        }
        const { moduleNodes, exportsArray, importsArray, declarationsArray, providersArray, moduleName, } = (0, lib_1.getModuleMetadataFromAST)(componentAST, componentFileContents);
        (0, lib_1.verifyModuleIsScam)(exportsArray, componentName, declarationsArray);
        (0, lib_1.convertScamToStandalone)(componentAST, componentFileContents, importsArray, providersArray, moduleNodes, tree, normalizedComponentPath, componentName);
        (0, lib_1.replaceModuleUsagesWithComponent)(tree, moduleName, componentName);
        if (!skipFormat) {
            yield (0, devkit_1.formatFiles)(tree);
        }
    });
}
exports.scamToStandalone = scamToStandalone;
exports.default = scamToStandalone;
