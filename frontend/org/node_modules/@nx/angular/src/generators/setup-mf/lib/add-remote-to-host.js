"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addRemoteToHost = exports.checkIsCommaNeeded = void 0;
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const route_utils_1 = require("../../../utils/nx-devkit/route-utils");
const ensure_typescript_1 = require("@nx/js/src/utils/typescript/ensure-typescript");
let tsModule;
function checkIsCommaNeeded(mfRemoteText) {
    const remoteText = mfRemoteText.replace(/\s+/g, '');
    return !remoteText.endsWith(',]')
        ? remoteText === '[]'
            ? false
            : true
        : false;
}
exports.checkIsCommaNeeded = checkIsCommaNeeded;
function addRemoteToHost(tree, options) {
    if (options.host) {
        const hostProject = (0, devkit_1.readProjectConfiguration)(tree, options.host);
        const pathToMFManifest = (0, devkit_1.joinPathFragments)(hostProject.sourceRoot, 'assets/module-federation.manifest.json');
        const hostFederationType = determineHostFederationType(tree, pathToMFManifest);
        if (hostFederationType === 'static') {
            addRemoteToStaticHost(tree, options, hostProject);
        }
        else if (hostFederationType === 'dynamic') {
            addRemoteToDynamicHost(tree, options, pathToMFManifest);
        }
        const declarationFilePath = (0, devkit_1.joinPathFragments)(hostProject.sourceRoot, 'remotes.d.ts');
        const declarationFileContent = (tree.exists(declarationFilePath)
            ? tree.read(declarationFilePath, 'utf-8')
            : '') +
            `\ndeclare module '${options.appName}/${options.standalone ? `Routes` : `Module`}';`;
        tree.write(declarationFilePath, declarationFileContent);
        addLazyLoadedRouteToHostAppModule(tree, options, hostFederationType);
    }
}
exports.addRemoteToHost = addRemoteToHost;
function determineHostFederationType(tree, pathToMfManifest) {
    return tree.exists(pathToMfManifest) ? 'dynamic' : 'static';
}
function addRemoteToStaticHost(tree, options, hostProject) {
    const hostMFConfigPath = (0, devkit_1.joinPathFragments)(hostProject.root, 'module-federation.config.js');
    if (!hostMFConfigPath || !tree.exists(hostMFConfigPath)) {
        throw new Error(`The selected host application, ${options.host}, does not contain a module-federation.config.js or module-federation.manifest.json file. Are you sure it has been set up as a host application?`);
    }
    const hostMFConfig = tree.read(hostMFConfigPath, 'utf-8');
    const { tsquery } = require('@phenomnomnominal/tsquery');
    const webpackAst = tsquery.ast(hostMFConfig);
    const mfRemotesNode = tsquery(webpackAst, 'Identifier[name=remotes] ~ ArrayLiteralExpression', { visitAllChildren: true })[0];
    const endOfPropertiesPos = mfRemotesNode.getEnd() - 1;
    const isCommaNeeded = checkIsCommaNeeded(mfRemotesNode.getText());
    const updatedConfig = `${hostMFConfig.slice(0, endOfPropertiesPos)}${isCommaNeeded ? ',' : ''}'${options.appName}',${hostMFConfig.slice(endOfPropertiesPos)}`;
    tree.write(hostMFConfigPath, updatedConfig);
}
function addRemoteToDynamicHost(tree, options, pathToMfManifest) {
    (0, devkit_1.updateJson)(tree, pathToMfManifest, (manifest) => {
        return Object.assign(Object.assign({}, manifest), { [options.appName]: `http://localhost:${options.port}` });
    });
}
// TODO(colum): future work: allow dev to pass to path to routing module
function addLazyLoadedRouteToHostAppModule(tree, options, hostFederationType) {
    if (!tsModule) {
        tsModule = (0, ensure_typescript_1.ensureTypescript)();
    }
    const hostAppConfig = (0, devkit_1.readProjectConfiguration)(tree, options.host);
    const pathToHostRootRouting = `${hostAppConfig.sourceRoot}/app/app.routes.ts`;
    if (!tree.exists(pathToHostRootRouting)) {
        return;
    }
    const hostRootRoutingFile = tree.read(pathToHostRootRouting, 'utf-8');
    let sourceFile = tsModule.createSourceFile(pathToHostRootRouting, hostRootRoutingFile, tsModule.ScriptTarget.Latest, true);
    if (hostFederationType === 'dynamic') {
        sourceFile = (0, js_1.insertImport)(tree, sourceFile, pathToHostRootRouting, 'loadRemoteModule', '@nx/angular/mf');
    }
    const routePathName = options.standalone ? 'Routes' : 'Module';
    const exportedRemote = options.standalone
        ? 'remoteRoutes'
        : 'RemoteEntryModule';
    const routeToAdd = hostFederationType === 'dynamic'
        ? `loadRemoteModule('${options.appName}', './${routePathName}')`
        : `import('${options.appName}/${routePathName}')`;
    (0, route_utils_1.addRoute)(tree, pathToHostRootRouting, `{
    path: '${options.appName}',
    loadChildren: () => ${routeToAdd}.then(m => m.${exportedRemote})
    }`);
    const pathToAppComponentTemplate = (0, devkit_1.joinPathFragments)(hostAppConfig.sourceRoot, 'app/app.component.html');
    const appComponent = tree.read(pathToAppComponentTemplate, 'utf-8');
    if (appComponent.includes(`<ul class="remote-menu">`) &&
        appComponent.includes('</ul>')) {
        const indexOfClosingMenuTag = appComponent.indexOf('</ul>');
        const newAppComponent = `${appComponent.slice(0, indexOfClosingMenuTag)}<li><a routerLink='${options.appName}'>${(0, devkit_1.names)(options.appName).className}</a></li>\n${appComponent.slice(indexOfClosingMenuTag)}`;
        tree.write(pathToAppComponentTemplate, newAppComponent);
    }
}
