"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.host = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const application_1 = require("../application/application");
const remote_1 = require("../remote/remote");
const project_1 = require("../utils/project");
const setup_mf_1 = require("../setup-mf/setup-mf");
const test_runners_1 = require("../../utils/test-runners");
const lib_1 = require("./lib");
const version_utils_1 = require("../utils/version-utils");
const semver_1 = require("semver");
function host(tree, options) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const installedAngularVersionInfo = (0, version_utils_1.getInstalledAngularVersionInfo)(tree);
        if ((0, semver_1.lt)(installedAngularVersionInfo.version, '14.1.0') && options.standalone) {
            throw new Error((0, devkit_1.stripIndents) `The "standalone" option is only supported in Angular >= 14.1.0. You are currently using ${installedAngularVersionInfo.version}.
    You can resolve this error by removing the "standalone" option or by migrating to Angular 14.1.0.`);
        }
        const projects = (0, devkit_1.getProjects)(tree);
        const remotesToGenerate = [];
        const remotesToIntegrate = [];
        if (options.remotes && options.remotes.length > 0) {
            options.remotes.forEach((remote) => {
                if (!projects.has(remote)) {
                    remotesToGenerate.push(remote);
                }
                else {
                    remotesToIntegrate.push(remote);
                }
            });
        }
        const { projectDirectory } = (0, devkit_1.extractLayoutDirectory)(options.directory);
        const appName = (0, project_1.normalizeProjectName)(options.name, projectDirectory);
        const appInstallTask = yield (0, application_1.default)(tree, Object.assign(Object.assign({}, options), { standalone: (_a = options.standalone) !== null && _a !== void 0 ? _a : false, routing: true, port: 4200, skipFormat: true }));
        const skipE2E = !options.e2eTestRunner || options.e2eTestRunner === test_runners_1.E2eTestRunner.None;
        yield (0, setup_mf_1.setupMf)(tree, {
            appName,
            mfType: 'host',
            routing: true,
            port: 4200,
            remotes: remotesToIntegrate !== null && remotesToIntegrate !== void 0 ? remotesToIntegrate : [],
            federationType: options.dynamic ? 'dynamic' : 'static',
            skipPackageJson: options.skipPackageJson,
            skipFormat: true,
            skipE2E,
            e2eProjectName: skipE2E ? undefined : `${appName}-e2e`,
            prefix: options.prefix,
        });
        let installTasks = [appInstallTask];
        if (options.ssr) {
            let ssrInstallTask = yield (0, lib_1.addSsr)(tree, options, appName);
            installTasks.push(ssrInstallTask);
        }
        for (const remote of remotesToGenerate) {
            yield (0, remote_1.default)(tree, Object.assign(Object.assign({}, options), { name: remote, host: appName, skipFormat: true, standalone: options.standalone }));
        }
        if (!options.skipFormat) {
            yield (0, devkit_1.formatFiles)(tree);
        }
        return (0, devkit_1.runTasksInSerial)(...installTasks);
    });
}
exports.host = host;
exports.default = host;
