"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const typescript_1 = require("typescript");
function default_1(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const printer = (0, typescript_1.createPrinter)();
        const projects = yield getProjectsWithAngularRouter(tree);
        for (const project of projects) {
            (0, devkit_1.visitNotIgnoredFiles)(tree, project.root, (filePath) => {
                // we are only interested in .ts files
                if (!filePath.endsWith('.ts')) {
                    return;
                }
                const content = tree.read(filePath, 'utf-8');
                const ast = tsquery_1.tsquery.ast(content);
                const routerModuleForRootCall = getRouterModuleForRootCall(ast);
                if (!routerModuleForRootCall) {
                    return;
                }
                const initialNavigationAssignment = getInitialNavigationAssignment(routerModuleForRootCall.arguments[1]);
                if (!initialNavigationAssignment) {
                    return;
                }
                const updatedInitialNavigationAssignment = printer.printNode(typescript_1.EmitHint.Unspecified, typescript_1.factory.updatePropertyAssignment(initialNavigationAssignment, initialNavigationAssignment.name, typescript_1.factory.createIdentifier(`'enabledBlocking'`)), initialNavigationAssignment.getSourceFile());
                const updatedContent = `${content.slice(0, initialNavigationAssignment.getStart())}${updatedInitialNavigationAssignment}${content.slice(initialNavigationAssignment.getEnd())}`;
                tree.write(filePath, updatedContent);
            });
        }
        yield (0, devkit_1.formatFiles)(tree);
    });
}
exports.default = default_1;
function getInitialNavigationAssignment(extraOptionsLiteral) {
    for (const prop of extraOptionsLiteral.properties) {
        if ((0, typescript_1.isPropertyAssignment)(prop) &&
            ((0, typescript_1.isIdentifier)(prop.name) || (0, typescript_1.isStringLiteralLike)(prop.name)) &&
            prop.name.text === 'initialNavigation' &&
            needsMigration(prop)) {
            return prop;
        }
    }
    return null;
}
function getProjectsWithAngularRouter(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const projectGraph = yield (0, devkit_1.createProjectGraphAsync)();
        return Object.entries(projectGraph.dependencies)
            .filter(([node, dep]) => dep.some(({ target }) => {
            var _a;
            return target === 'npm:@angular/router' &&
                !((_a = projectGraph.externalNodes) === null || _a === void 0 ? void 0 : _a[node]);
        }))
            .map(([projectName]) => (0, devkit_1.readProjectConfiguration)(tree, projectName));
    });
}
function getRouterModuleForRootCall(sourceFile) {
    // narrow down call expressions
    const routerModuleForRootCalls = (0, tsquery_1.tsquery)(sourceFile, 'CallExpression:has(PropertyAccessExpression:has(Identifier[name=RouterModule]):has(Identifier[name=forRoot]))', { visitAllChildren: true });
    for (const node of routerModuleForRootCalls) {
        if (isRouterModuleForRoot(node) &&
            node.arguments.length >= 2 &&
            (0, typescript_1.isObjectLiteralExpression)(node.arguments[1])) {
            return node;
        }
    }
    return null;
}
function isRouterModuleForRoot(node) {
    // make sure is not an outer call expression (NgModule call)
    const routerModuleForRootIdentifier = (0, tsquery_1.tsquery)(node.expression, 'CallExpression > PropertyAccessExpression > Identifier[name=RouterModule] ~ Identifier[name=forRoot]', { visitAllChildren: true })[0];
    return !!routerModuleForRootIdentifier;
}
function needsMigration(node) {
    return ((0, typescript_1.isStringLiteralLike)(node.initializer) && node.initializer.text === 'enabled');
}
