"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nxComponentTestingPreset = void 0;
const cypress_preset_1 = require("@nx/cypress/plugins/cypress-preset");
const ct_helpers_1 = require("@nx/cypress/src/utils/ct-helpers");
const devkit_1 = require("@nx/devkit");
const fs_1 = require("fs");
const path_1 = require("path");
const semver_1 = require("semver");
/**
 * Angular nx preset for Cypress Component Testing
 *
 * This preset contains the base configuration
 * for your component tests that nx recommends.
 * including a devServer that supports nx workspaces.
 * you can easily extend this within your cypress config via spreading the preset
 * @example
 * export default defineConfig({
 *   component: {
 *     ...nxComponentTestingPreset(__filename)
 *     // add your own config here
 *   }
 * })
 *
 * @param pathToConfig will be used for loading project options and to construct the output paths for videos and screenshots
 * @param options override options
 */
function nxComponentTestingPreset(pathToConfig, options) {
    var _a, _b, _c, _d, _e;
    let graph;
    try {
        graph = (0, devkit_1.readCachedProjectGraph)();
    }
    catch (e) {
        throw new Error(
        // don't want to strip indents so error stack has correct indentation
        `Unable to read the project graph for component testing.
This is likely due to not running via nx. i.e. 'nx component-test my-project'.
Please open an issue if this error persists.
${e.stack ? e.stack : e}`);
    }
    const ctProjectConfig = (0, ct_helpers_1.getProjectConfigByPath)(graph, pathToConfig);
    const ctConfigurationName = process.env.NX_CYPRESS_TARGET_CONFIGURATION;
    const ctContext = (0, ct_helpers_1.createExecutorContext)(graph, ctProjectConfig.targets, ctProjectConfig.name, (options === null || options === void 0 ? void 0 : options.ctTargetName) || 'component-test', ctConfigurationName);
    const buildTarget = getBuildableTarget(ctContext);
    if (!buildTarget.project && !((_b = (_a = graph.nodes) === null || _a === void 0 ? void 0 : _a[buildTarget.project]) === null || _b === void 0 ? void 0 : _b.data)) {
        throw new Error((0, devkit_1.stripIndents) `Unable to find project configuration for build target. 
    Project Name? ${buildTarget.project}
    Has project config? ${!!((_d = (_c = graph.nodes) === null || _c === void 0 ? void 0 : _c[buildTarget.project]) === null || _d === void 0 ? void 0 : _d.data)}`);
    }
    const fromWorkspaceRoot = (0, path_1.relative)(ctContext.root, pathToConfig);
    const normalizedFromWorkspaceRootPath = (0, fs_1.lstatSync)(pathToConfig).isFile()
        ? (0, path_1.dirname)(fromWorkspaceRoot)
        : fromWorkspaceRoot;
    const offset = isOffsetNeeded(ctContext, ctProjectConfig)
        ? (0, devkit_1.offsetFromRoot)(normalizedFromWorkspaceRootPath)
        : undefined;
    const buildContext = (0, ct_helpers_1.createExecutorContext)(graph, (_e = graph.nodes[buildTarget.project]) === null || _e === void 0 ? void 0 : _e.data.targets, buildTarget.project, buildTarget.target, buildTarget.configuration);
    const buildableProjectConfig = normalizeBuildTargetOptions(buildContext, ctContext, offset);
    return Object.assign(Object.assign({}, (0, cypress_preset_1.nxBaseCypressPreset)(pathToConfig)), { 
        // NOTE: cannot use a glob pattern since it will break cypress generated tsconfig.
        specPattern: ['src/**/*.cy.ts', 'src/**/*.cy.js'], 
        // cypress defaults to a relative path from the workspaceRoot instead of projectRoot
        // set as absolute path in case this changes internally to cypress, this path isn't OS dependent
        indexHtmlFile: (0, devkit_1.joinPathFragments)(ctContext.root, ctProjectConfig.root, 'cypress', 'support', 'component-index.html'), devServer: Object.assign(Object.assign({}, {
            framework: 'angular',
            bundler: 'webpack',
        }), { options: {
                projectConfig: buildableProjectConfig,
            } }) });
}
exports.nxComponentTestingPreset = nxComponentTestingPreset;
function getBuildableTarget(ctContext) {
    var _a, _b;
    const targets = (_b = (_a = ctContext.projectGraph.nodes[ctContext.projectName]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.targets;
    const targetConfig = targets === null || targets === void 0 ? void 0 : targets[ctContext.targetName];
    if (!targetConfig) {
        throw new Error((0, devkit_1.stripIndents) `Unable to find component testing target configuration in project '${ctContext.projectName}'.
      Has targets? ${!!targets}
      Has target name? ${ctContext.targetName}
      Has ct project name? ${ctContext.projectName}
      `);
    }
    const cypressCtOptions = (0, devkit_1.readTargetOptions)({
        project: ctContext.projectName,
        target: ctContext.targetName,
        configuration: ctContext.configurationName,
    }, ctContext);
    if (!cypressCtOptions.devServerTarget) {
        throw new Error(`Unable to find the 'devServerTarget' executor option in the '${ctContext.targetName}' target of the '${ctContext.projectName}' project`);
    }
    return (0, devkit_1.parseTargetString)(cypressCtOptions.devServerTarget, ctContext.projectGraph);
}
function normalizeBuildTargetOptions(buildContext, ctContext, offset) {
    var _a, _b;
    const options = (0, devkit_1.readTargetOptions)({
        project: buildContext.projectName,
        target: buildContext.targetName,
        configuration: buildContext.configurationName,
    }, buildContext);
    const buildOptions = withSchemaDefaults(options);
    // cypress creates a tsconfig if one isn't preset
    // that contains all the support required for angular and component tests
    delete buildOptions.tsConfig;
    if (offset) {
        // polyfill entries might be local files or files that are resolved from node_modules
        // like zone.js.
        // prevents error from webpack saying can't find <offset>/zone.js.
        const handlePolyfillPath = (polyfill) => {
            const maybeFullPath = (0, path_1.join)(ctContext.root, polyfill.split('/').join(path_1.sep));
            if ((0, fs_1.existsSync)(maybeFullPath)) {
                return (0, devkit_1.joinPathFragments)(offset, polyfill);
            }
            return polyfill;
        };
        // paths need to be unix paths for angular devkit
        if (buildOptions.polyfills) {
            buildOptions.polyfills =
                Array.isArray(buildOptions.polyfills) &&
                    buildOptions.polyfills.length > 0
                    ? buildOptions.polyfills.map((p) => handlePolyfillPath(p))
                    : handlePolyfillPath(buildOptions.polyfills);
        }
        buildOptions.main = (0, devkit_1.joinPathFragments)(offset, buildOptions.main);
        buildOptions.index =
            typeof buildOptions.index === 'string'
                ? (0, devkit_1.joinPathFragments)(offset, buildOptions.index)
                : Object.assign(Object.assign({}, buildOptions.index), { input: (0, devkit_1.joinPathFragments)(offset, buildOptions.index.input) });
        buildOptions.fileReplacements = buildOptions.fileReplacements.map((fr) => {
            fr.replace = (0, devkit_1.joinPathFragments)(offset, fr.replace);
            fr.with = (0, devkit_1.joinPathFragments)(offset, fr.with);
            return fr;
        });
    }
    // if the ct project isn't being used in the build project
    // then we don't want to have the assets/scripts/styles be included to
    // prevent inclusion of unintended stuff like tailwind
    if (buildContext.projectName === ctContext.projectName ||
        (0, ct_helpers_1.isCtProjectUsingBuildProject)(ctContext.projectGraph, buildContext.projectName, ctContext.projectName)) {
        if (offset) {
            buildOptions.assets = buildOptions.assets.map((asset) => {
                return typeof asset === 'string'
                    ? (0, devkit_1.joinPathFragments)(offset, asset)
                    : Object.assign(Object.assign({}, asset), { input: (0, devkit_1.joinPathFragments)(offset, asset.input) });
            });
            buildOptions.styles = buildOptions.styles.map((style) => {
                return typeof style === 'string'
                    ? (0, devkit_1.joinPathFragments)(offset, style)
                    : Object.assign(Object.assign({}, style), { input: (0, devkit_1.joinPathFragments)(offset, style.input) });
            });
            buildOptions.scripts = buildOptions.scripts.map((script) => {
                return typeof script === 'string'
                    ? (0, devkit_1.joinPathFragments)(offset, script)
                    : Object.assign(Object.assign({}, script), { input: (0, devkit_1.joinPathFragments)(offset, script.input) });
            });
            if (((_a = buildOptions.stylePreprocessorOptions) === null || _a === void 0 ? void 0 : _a.includePaths.length) > 0) {
                buildOptions.stylePreprocessorOptions = {
                    includePaths: buildOptions.stylePreprocessorOptions.includePaths.map((path) => {
                        return (0, devkit_1.joinPathFragments)(offset, path);
                    }),
                };
            }
        }
    }
    else {
        const stylePath = getTempStylesForTailwind(ctContext);
        buildOptions.styles = stylePath ? [stylePath] : [];
        buildOptions.assets = [];
        buildOptions.scripts = [];
        buildOptions.stylePreprocessorOptions = { includePaths: [] };
    }
    const config = (_b = buildContext.projectGraph.nodes[buildContext.projectName]) === null || _b === void 0 ? void 0 : _b.data;
    if (!config.sourceRoot) {
        devkit_1.logger.warn((0, devkit_1.stripIndents) `Unable to find the 'sourceRoot' in the project configuration.
Will set 'sourceRoot' to '${config.root}/src'
Note: this may fail, setting the correct 'sourceRoot' for ${buildContext.projectName} in the project.json file will ensure the correct value is used.`);
        config.sourceRoot = (0, devkit_1.joinPathFragments)(config.root, 'src');
    }
    return {
        root: offset ? (0, devkit_1.joinPathFragments)(offset, config.root) : config.root,
        sourceRoot: offset
            ? (0, devkit_1.joinPathFragments)(offset, config.sourceRoot)
            : config.sourceRoot,
        buildOptions: Object.assign(Object.assign({}, buildOptions), { 
            // this property is only valid for cy v12.9.0+
            workspaceRoot: offset ? undefined : ctContext.root }),
    };
}
function withSchemaDefaults(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    if (!options.main) {
        throw new Error('Missing executor options "main"');
    }
    if (!options.index) {
        throw new Error('Missing executor options "index"');
    }
    if (!options.tsConfig) {
        throw new Error('Missing executor options "tsConfig"');
    }
    // cypress defaults aot to false so we cannot use buildOptimizer
    // otherwise the 'buildOptimizer' cannot be used without 'aot' error is thrown
    options.buildOptimizer = false;
    options.aot = false;
    (_a = options.assets) !== null && _a !== void 0 ? _a : (options.assets = []);
    (_b = options.allowedCommonJsDependencies) !== null && _b !== void 0 ? _b : (options.allowedCommonJsDependencies = []);
    (_c = options.budgets) !== null && _c !== void 0 ? _c : (options.budgets = []);
    (_d = options.commonChunk) !== null && _d !== void 0 ? _d : (options.commonChunk = true);
    (_e = options.crossOrigin) !== null && _e !== void 0 ? _e : (options.crossOrigin = 'none');
    (_f = options.deleteOutputPath) !== null && _f !== void 0 ? _f : (options.deleteOutputPath = true);
    (_g = options.extractLicenses) !== null && _g !== void 0 ? _g : (options.extractLicenses = true);
    (_h = options.fileReplacements) !== null && _h !== void 0 ? _h : (options.fileReplacements = []);
    (_j = options.inlineStyleLanguage) !== null && _j !== void 0 ? _j : (options.inlineStyleLanguage = 'css');
    (_k = options.i18nDuplicateTranslation) !== null && _k !== void 0 ? _k : (options.i18nDuplicateTranslation = 'warning');
    (_l = options.outputHashing) !== null && _l !== void 0 ? _l : (options.outputHashing = 'none');
    (_m = options.progress) !== null && _m !== void 0 ? _m : (options.progress = true);
    (_o = options.scripts) !== null && _o !== void 0 ? _o : (options.scripts = []);
    return options;
}
/**
 * @returns a path from the workspace root to a temp file containing the base tailwind setup
 * if tailwind is being used in the project root or workspace root
 * this file should get cleaned up via the cypress executor
 */
function getTempStylesForTailwind(ctExecutorContext) {
    var _a;
    const ctProjectConfig = (_a = ctExecutorContext.projectGraph.nodes[ctExecutorContext.projectName]) === null || _a === void 0 ? void 0 : _a.data;
    // angular only supports `tailwind.config.{js,cjs}`
    const ctProjectTailwindConfig = (0, path_1.join)(ctExecutorContext.root, ctProjectConfig.root, 'tailwind.config');
    const exts = ['js', 'cjs'];
    const isTailWindInCtProject = exts.some((ext) => (0, fs_1.existsSync)(`${ctProjectTailwindConfig}.${ext}`));
    const rootTailwindPath = (0, path_1.join)(ctExecutorContext.root, 'tailwind.config');
    const isTailWindInRoot = exts.some((ext) => (0, fs_1.existsSync)(`${rootTailwindPath}.${ext}`));
    if (isTailWindInRoot || isTailWindInCtProject) {
        const pathToStyle = (0, ct_helpers_1.getTempTailwindPath)(ctExecutorContext);
        try {
            (0, fs_1.mkdirSync)((0, path_1.dirname)(pathToStyle), { recursive: true });
            (0, fs_1.writeFileSync)(pathToStyle, `
@tailwind base;
@tailwind components;
@tailwind utilities;
`, { encoding: 'utf-8' });
            return pathToStyle;
        }
        catch (makeTmpFileError) {
            devkit_1.logger.warn((0, devkit_1.stripIndents) `Issue creating a temp file for tailwind styles. Defaulting to no tailwind setup.
      Temp file path? ${pathToStyle}`);
            devkit_1.logger.error(makeTmpFileError);
        }
    }
}
function isOffsetNeeded(ctExecutorContext, ctProjectConfig) {
    try {
        const { version = null } = require('cypress/package.json');
        const supportsWorkspaceRoot = !!version && (0, semver_1.gte)(version, '12.9.0');
        // if using cypress <v12.9.0 then we require the offset
        if (!supportsWorkspaceRoot) {
            return true;
        }
        if (ctProjectConfig.projectType === 'library' &&
            // angular will only see this config if the library root is the build project config root
            // otherwise it will be set to the buildTarget root which is the app root where this config doesn't exist
            // causing tailwind styles from the libs project root to not work
            ['js', 'cjs'].some((ext) => (0, fs_1.existsSync)((0, path_1.join)(ctExecutorContext.root, ctProjectConfig.root, `tailwind.config.${ext}`)))) {
            return true;
        }
        return false;
    }
    catch (e) {
        if (process.env.NX_VERBOSE_LOGGING === 'true') {
            devkit_1.logger.error(e);
        }
        // unable to determine if we don't require an offset
        // safest to assume we do
        return true;
    }
}
